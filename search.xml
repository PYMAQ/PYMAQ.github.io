<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习和python学习之路吐血整理大数据技术书从入门到进阶最全本(珍藏版)]]></title>
    <url>%2F2018%2F10%2F06%2FmachineLearning%2F</url>
    <content type="text"><![CDATA[“机器学习／深度学习并不需要很多数学基础！”也许你在不同的地方听过不少类似这样的说法。对于鼓励数学基础不好的同学入坑机器学习来说，这句话是挺不错的。不过，机器学习理论是与统计学、概率论、计算机科学、算法等方面交叉的领域，对这些技术有一个全面的数学理解对理解算法的内部工作机制、获取好的结果是有必要的。机器学习确实需要对一些数学领域有深入理解，缺乏必要的数学知识，很可能在更深入的学习中不断遇到挫折，甚至导致放弃。说的很多小伙伴恐怕心都凉了一半，或者已经开始打退堂鼓了。不要紧，山人自有妙法。下面就给大家分享一下，主要是一些资源（书籍或者视频课程）。人工智能（机器学习或数据挖掘等）中最最重要的数学就是线性代数与概率论（还有其他，但这两者比重最大）。 所以我找了个书单自学，电子书为主，顺便分享出来。使用电子书的形式是因为，个人偏好。即使我买了实体书，一旦找到了电子书，我马上就会把纸质书扔到床底下。如果侵犯了任何人的权益，烦请及时通知。 前言： 技术书阅读方法论一.速读一遍（最好在1~2天内完成）人的大脑记忆力有限，在一天内快速看完一本书会在大脑里留下深刻印象，对于之后复习以及总结都会有特别好的作用。对于每一章的知识，先阅读标题，弄懂大概讲的是什么主题，再去快速看一遍，不懂也没有关系，但是一定要在不懂的地方做个记号，什么记号无所谓，但是要让自己后面再看的时候有个提醒的作用，看看第二次看有没有懂了些。二.精读一遍（在2周内看完）（并且记得看下面的博文）有了前面速读的感觉，第二次看会有慢慢深刻了思想和意识的作用，具体为什么不要问我，去问30年后的神经大脑专家，现在人类可能还没有总结出为什么大脑对记忆的完全方法论，但是，就像我们专业程序员，打代码都是先实践，然后就渐渐懂了过程，慢慢懂了原理，所以第二遍读的时候稍微慢下来，2周内搞定。记住一句话：没看完一个章节后，总结一下这个章节讲了啥。很关键。三.实践（在整个过程中都要）实践的时候，要注意不用都去实践，最好看着书，敲下代码，把重点的内容敲一遍有个肌肉记忆就很不错了。以及到自己做过的项目中去把每个有涉及的原理的代码，研究一遍，就可以了。 百度网盘链接：https://pan.baidu.com/s/1wIL_5arbxhjvzWeyba89kA提取码：b379备注：文件比较大，网盘直接打开会显示损坏，里面已经整理并且压缩好，需要下载后才可以打。 一. 数学基础1.微积分：《微积分学教程》 （F.M.菲赫金哥尔茨）俄罗斯的数学书2.线性代数：《Linear Algebra and Its Applications,Third Edition （David C.Lay）》讲得很实际，线性代数最重要的就是与实际应用相联系才能够理解其意义3.概率与统计：《概率论与数理统计 （陈希孺）》或《概率论与数理统计（盛骤/谢式千/潘承毅）》这两本书都很不错 ![3.1.png](https://i.loli.net/2018/10/27/5bd3d780336eb.png) 4.随机过程：《应用随机过程:概率模型导论 （Sheldon M. Ross）》这本书已经出到第10版了这四门是数学的基础，当然数学本身就是博大精深的。 二. 机器学习与数据挖掘（偏理论）1.《 统计学习方法 （李航）》 2.《统计学习基础 （Trevor Hastie, Robert Tibshirani, Jerome Friedman）》 3.《Pattern Recognition and Machine Learning （Christopher Bishop）》 4.《Introduction to Machine Learning （Ethem Alpaydin）》（《机器学习导论》） 6.《Data Mining （韩家炜） 》 7.《现代模式识别 （孙即祥） 》 个人觉得《统计学习方法》与《统计学习基础》这两本书是基础，后面的书内容相差不大，所以前两本书应该看，而入门的话，后面的书可以选1到2本精读，剩下的书可作参考。 三. 智能算法（偏应用）1.《Web智能算法 （Haralambos Marmanis, Dmitry Babenko）》 2.《集体智慧编程 （Toby Segaran）》 3.《推荐系统实践 （项亮）》 4.《数据之魅 （Pbilipp K.Janert）》 这几本书均是从实践的角度讲解了机器学习中常用的算法，非常值得一看。有人推荐，学习机器学习的话可以先读《统计学习方法》和《统计学习基础》打底，这样就包含了大部分的算法，然后再深入研究某个算法。 四.机器学习入门级：1.《数学之美》；作者吴军大家都很熟悉。这本书主要的作用是引起了我对机器学习和自然语言处理的兴趣。里面以极为通俗的语言讲述了数学在这两个领域的应用。 2.《Programming Collective Intelligence》（中译本《集体智慧编程》）；作者Toby Segaran也是《BeautifulData : The Stories Behind Elegant Data Solutions》（《数据之美：解密优雅数据解决方案背后的故事》）的作者。这本书最大的优势就是里面没有理论推导和复杂的数学公式，是很不错的入门书。目前中文版已经脱销，对于有志于这个领域的人来说，英文的pdf是个不错的选择，因为后面有很多经典书的翻译都较差，只能看英文版，不如从这个入手。还有，这本书适合于快速看完，因为据评论，看完一些经典的带有数学推导的书后会发现这本书什么都没讲，只是举了很多例子而已。 3.《Algorithms of the Intelligent Web》（中译本《智能web算法》）；作者Haralambos Marmanis、Dmitry Babenko。这本书中的公式比《集体智慧编程》要略多一点，里面的例子多是互联网上的应用，看名字就知道。不足的地方在于里面的配套代码是BeanShell而不是python或其他。总起来说，这本书还是适合初学者，与上一本一样需要快速读完，如果读完上一本的话，这一本可以不必细看代码，了解算法主要思想就行了。 4.《统计学习方法》；作者李航，是国内机器学习领域的几个大家之一，曾在MSRA任高级研究员，现在华为诺亚方舟实验室。书中写了十个算法，每个算法的介绍都很干脆，直接上公式，是彻头彻尾的“干货书”。每章末尾的参考文献也方便了想深入理解算法的童鞋直接查到经典论文；本书可以与上面两本书互为辅助阅读。 5.《Machine Learning》（《机器学习》）；作者TomMitchell[2]是CMU的大师，有机器学习和半监督学习的网络课程视频。这本书是领域内翻译的较好的书籍，讲述的算法也比《统计学习方法》的范围要大很多。据评论这本书主要在于启发，讲述公式为什么成立而不是推导；不足的地方在于出版年限较早，时效性不如PRML。但有些基础的经典还是不会过时的，所以这本书现在几乎是机器学习的必读书目。那么Mitchell的&lt;机器学习&gt;是经典的入门之作。当然，因为年代久远，很多新的模型都没有涉及到，但不影响他的经典性——入门级。 6.《机器学习实战》对于程序员，想快速了解模型流程和优缺点的，甚至是实现模型的，那么是我比较推荐的，现在已经有中文版了&lt;机器学习实战&gt;。这本书，提到了很多常见的模型，开始就是模型背景简介，之后是模型优缺点和应用场景、在接着算法实现和案例。而且，在书的最后，提及了一些比较切合时代的话题——大数据下机器学习。《机器学习基础》对于想从事机器学习的入门人员，比较推荐一本有中文版的&lt;机器学习基础&gt;(Simon Rogers的，英国格拉斯哥大学计算机科学学院讲师)，这本书适合高年级本科生和研究生。从理论的角度，推导了各个算法，以及探究了各个模型的特性等。涉及数学和矩阵的地方，都有详细的参照。适合高端点的入门，看这本书，可以体会一下自己的数学和矩阵，有种必须要加强的感觉。 7.《Mining of Massive Datasets》（《大数据》）；作者Anand Rajaraman[3]、Jeffrey David Ullman，Anand是Stanford的PhD。这本书介绍了很多算法，也介绍了这些算法在数据规模比较大的时候的变形。但是限于篇幅，每种算法都没有展开讲的感觉，如果想深入了解需要查其他的资料，不过这样的话对算法进行了解也足够了。还有一点不足的地方就是本书原文和翻译都有许多错误，勘误表比较长，读者要用心了。 8.《Data Mining: Practical Machine Learning Tools and Techniques》（《数据挖掘：实用机器学习技术》）；作者Ian H. Witten 、Eibe Frank是weka的作者、新西兰怀卡托大学教授。他们的《ManagingGigabytes》[4]也是信息检索方面的经典书籍。这本书最大的特点是对weka的使用进行了介绍，但是其理论部分太单薄，作为入门书籍还可，但是，经典的入门书籍如《集体智慧编程》、《智能web算法》已经很经典，学习的话不宜读太多的入门书籍，建议只看一些上述两本书没讲到的算法。 五.机器学习深入级：1.《Pattern Classification》（《模式分类》第二版）；作者Richard O. Duda[5]、Peter E. Hart、David。模式识别的奠基之作，但对最近呈主导地位的较好的方法SVM、Boosting方法没有介绍，被评“挂一漏万之嫌”。 2.《The Elements of Statistical Learning : Data Mining, Inference, andPrediction》，（《统计学习基础：数据挖掘、推理与预测》第二版）；作者RobertTibshirani、Trevor Hastie、Jerome Friedman。“这本书的作者是Boosting方法最活跃的几个研究人员，发明的Gradient Boosting提出了理解Boosting方法的新角度，极大扩展了Boosting方法的应用范围。这本书对当前最为流行的方法有比较全面深入的介绍，对工程人员参考价值也许要更大一点。另一方面，它不仅总结了已经成熟了的一些技术，而且对尚在发展中的一些议题也有简明扼要的论述。让读者充分体会到机器学习是一个仍然非常活跃的研究领域，应该会让学术研究人员也有常读常新的感受。”[7] 机器学习与数据挖掘（偏理论） 百度网盘链接：https://pan.baidu.com/s/1wIL_5arbxhjvzWeyba89kA提取码：b379 备注：文件比较大，网盘直接打开会显示损坏，里面已经整理并且压缩好，需要下载后才可以打。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之汉诺塔求解策略《六》]]></title>
    <url>%2F2018%2F09%2F06%2FjavaForSix%2F</url>
    <content type="text"><![CDATA[java版汉诺塔1234567891011121314151617181920212223242526272829public class Hanoi &#123; public static void main(String[] args)&#123; Hanoi.hanoi(3,'A','B','C'); &#125; public static void hanoi(int n,char a,char b,char c)&#123; ZF z = new ZF(); if(n==1)&#123; print(a,c); &#125; else&#123; hanoi(n-1,a,c,b); print(a,c); hanoi(n-1,b,a,c); &#125; System.out.println("---------第"+(ZF.x++)+"次递归---------------------------------"); &#125; public static void print(char a,char c)&#123; System.out.println("盘子从"+a+"---&gt;"+c); &#125;&#125; class ZF &#123; static public int x=1;&#125;//思想是将全局变量X设置成SS类的属性，//再在SS中添加fuzhi方法，来改变X的值。 汉诺塔求解推荐阅读博客：https://www.bilibili.com/video/av7398130/https://blog.csdn.net/xb2355404/article/details/79144451https://www.cnblogs.com/antineutrino/p/3334540.html]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python从入门到进阶推荐书籍最全整理pdf分享附网盘链接已拿BT豆瓣offer]]></title>
    <url>%2F2018%2F09%2F06%2FPython%2F</url>
    <content type="text"><![CDATA[从八月底开始找工作，短短的一星期多一些，面试了9家公司，拿到5份Offer，可能是因为我所面试的公司都是些创业性的公司吧，不过还是感触良多，因为学习Python的时间还很短，没想到还算比较容易的找到了工作，就把自己找的python资源和大家分享一下，希望为学习Python找工作的小伙伴们提供些许帮助。作为Python爱好者，广泛搜集了关于Python的书籍，具体包括数据挖掘、人工智能、网络编程等，范围广，资料全面，多为可编辑的pdf版本，不少都是各学科领域Python的书籍。当然论坛也有这些书籍，但是有的书籍较为难找，且大多数需要论坛币。为此，本人花费大量时间搜集整理Python书籍，并上传以下超过100本书籍，希望能够为Python爱 好者节省搜集书籍的时间，相互交流，共同学习。Python具有一些特征，使其成为第一种编程语言的接近完美的选择。Python基本结构简单、干净、设计精良，使学生能够专注于算法思维和程序设计的主要技能，而不会陷晦涩难解的语言细节。在Python中学习的概念可以直接传递给后续学习的系统语言（如C ++和Java）。但Python不是一种“玩具语言”，它是一种现实世界的生产语言，可以在几乎每个编程平台上免费提供，并且具有自己易于使用的集成编程环境。最好的是，Python让学习编程又变得有趣了。 前言： 技术书阅读方法论一.速读一遍（最好在1~2天内完成）人的大脑记忆力有限，在一天内快速看完一本书会在大脑里留下深刻印象，对于之后复习以及总结都会有特别好的作用。对于每一章的知识，先阅读标题，弄懂大概讲的是什么主题，再去快速看一遍，不懂也没有关系，但是一定要在不懂的地方做个记号，什么记号无所谓，但是要让自己后面再看的时候有个提醒的作用，看看第二次看有没有懂了些。二.精读一遍（在2周内看完）（并且记得看下面的博文）有了前面速读的感觉，第二次看会有慢慢深刻了思想和意识的作用，具体为什么不要问我，去问30年后的神经大脑专家，现在人类可能还没有总结出为什么大脑对记忆的完全方法论，但是，就像我们专业程序员，打代码都是先实践，然后就渐渐懂了过程，慢慢懂了原理，所以第二遍读的时候稍微慢下来，2周内搞定。记住一句话：没看完一个章节后，总结一下这个章节讲了啥。很关键。三.实践（在整个过程中都要）实践的时候，要注意不用都去实践，最好看着书，敲下代码，把重点的内容敲一遍有个肌肉记忆就很不错了。以及到自己做过的项目中去把每个有涉及的原理的代码，研究一遍，就可以了。 百度网盘链接：https://pan.baidu.com/s/1yujN2BoaObDJYBFKqcghkg提取码：9c4n备注：里面已经顺便整理压缩好，需要下载后才可以打开，网盘直接打开会显示损坏。 首先推荐大家通过这两本书来入门数据挖掘这个领域，python数据挖掘这本书较容易，还花了很大的篇幅来讲python基础，而python数据挖掘入门与实践则直接从实例讲起，需要读者有一定的python基础。 数据挖掘主要是通过python或者Ｒ语言来实现的，因为这两门语言有它们独特的优势，比如包含大量的函数式编程接口，高效的模块等等，这些都使它们非常适合用来进行数据挖掘和数据分析。所以都要求编程者要有这方面的知识体系。但是，说到底语言只是一个工具，真正要在一门领域取得建树，还是要靠编程者的思维能力和实践能力，比如算法水平和编码或者debug（项目）能力。不过，对python这个强大工具有很深入的了解，会对数据挖掘的学习有事半功倍的效果。 推荐使用anaconda作为python的编译库，里面包括了大量的实用模块，比如numpy(科学计算，如矩阵，二维数组，与表格最为相似的数据结构),pandas(数据分析，如数据框（虚拟内存数据库），系列),Scipy(科学计算，向量化思想，包括符号计算和函数向量化),scikit-learn(用于机器学习，数据挖掘，数据分析，六大功能：分类，回归，聚类，降维，模型选择，预处理),Matplotlib,Bokeh(数据分析及可视化)等等。这些都有助于进行数据挖掘和数据分析。 数据挖掘和数据分析等领域包含了大量的算法，比如K-Means,DBSCAN,Apriori,kNN,朴素贝叶斯，BP神经网络,CART，决策树等算法，这对编程者的算法能力和思维能力产生了极大的挑战。只有掌握了这些算法，才能更好地，更高效地，更快速地实现目标。如果有ACM经验的话，学起来应该会更加快速和适应。这些算法，我觉得结合实际例子来学习可能更加容易理解，比如用决策树来预测获胜球队，使用朴素贝叶斯进行社会媒体挖掘，用神经网络破解验证码，用深度学习方法为图像中的物体进行分类。结合实例的话，可以更好地去学习,理解和实践。 最后给大家推荐后续的学习路线，可以去kaggle上参加数据挖掘比赛，或者参考学习别人的优秀项目。还可以去coursera上面学习数据挖掘的相关课程，进一步提高自己的能力和拓展自己的视野。 1《《区块链中文词典》维京&amp;甲子》PDF版.pdf2《Beautiful_Soup中文文档》PDF版.pdf3《Head_First_Python（中文版）》PDF版.pdf4《Intermediate_Python中文译本》PDF版.pdf5《Keras中文手册》PDF版.pdf6《Node.js区块链开发》PDF版.pdf7《NumPy攻略Python科学计算与数据分析_［（印尼）IvanIdris著；张崇明译］［人民邮电出版社］［2013.10］［174页］》PDF版.pdf8《Phthon编程金典》PDF版.pdf9《Python3程序开发指南（美）萨默菲尔德.扫描版》PDF版.pdf10《Python3网络爬虫数据采集》PDF版.pdf11《Python100经典练习题》PDF版.pdf12《python_by_Liao》PDF版.pdf13《python_cookbook（第3版）高清中文完整版》PDF版.pdf14《Python_Web开发：测试驱动方法》PDF版.pdf15《PythonWeb开发实战pdf解压密码》PDF版.pdf16《Python_Web开发实战》PDF版.pdf17《Python_文本处理指南［经典］》PDF版.pdf18《Python文本处理指南［经典］pdf解压密码》PDF版.pdf19《python cookbook(第3版)高清中文完整版(###)》PDF版.pdf20《PYTHON QT GUI快速编程 PYQT编程指南 ,马克·萨默菲尔德 ,P444 ,2016.08》PDF版.pdf21《Python编程：从入门到实践(#)》PDF版.pdf22《Python编程初学者指南》PDF版.pdf23《Python编程导论第2版_2018（#）》PDF版.pdf24《Python编程快速上手—让繁琐工作自动化_PDF中文高清晰完整版》PDF版.pdf25《Python编程快速上手让繁琐工作自动化》PDF版.pdf26《Python编程入门 第3版》PDF版.pdf27《Python编程入门经典》PDF版.pdf28《Python编程实战运用设计模式、并发和程序库创建高质量程序PDF电子书下载带书签目录完整版》PDF版.pdf29《python标准库》PDF版.pdf30《Python参考手册(第4版)》PDF版.pdf31《Python程序员指南》PDF版.pdf32《Python初学教程：《简明Python教程》》PDF版.pdf33《Python地理空间分析指南（第2版）》PDF版.pdf34《Python高级编程（清华）》PDF版.pdf35《Python高级编程第2版张亮 阿信（译）_人民邮电出版社_2017-10_v2_完整版》PDF版.pdf36《Python高性能编程》PDF版.pdf37《Python核心编程第3版中文版》PDF版.pdf38《Python核心编程中文》PDF版.pdf39《Python灰帽子——黑客与逆向工程师的Python编程之道》PDF版.pdf40《Python灰帽子》PDF版.pdf41《PYTHON机器学习及实践－从零开始通往KAGGLE竞赛之路》PDF版.pdf42《Python基础教程（第3版）（#）》PDF版.pdf43《Python技术参考大全》PDF版.pdf44《Python金融大数据分析》PDF版.pdf45《Python进阶（Intermediate_Python）中文PDF彩色版》PDF版.pdf46《Python开发技术详解》PDF版.pdf47《Python开发实战(PDF版)》PDF版.pdf48《Python开发实战》PDF版.pdf49《Python科学计算(#)》PDF版.pdf50《Python科学计算张若愚》PDF版.pdf51《PYTHON面向对象编程指南 [（美）STEVEN F.LOTT著；张心韬，兰亮译][人民邮电出版》PDF版.pdf52《Python爬虫开发与项目实战》PDF版.pdf53《Python入门经典以解决计算问题为导向的Python编程》PDF版.pdf54《Python数据处理(###)》PDF版.pdf55《Python数据处理》PDF版.pdf56《Python数据分析基础》PDF版.pdf57《Python数据分析基础教程：NumPy学习指南（第2版）(1)》PDF版.pdf58《Python数据分析基础教程：NumPy学习指南（第2版）》PDF版.pdf59《Python数据分析实战_2016版》PDF版.pdf60《Python数据科学手册》PDF版.pdf61《PYTHON数据可视化编程实战》PDF版.pdf62《PYTHON数据可视化编程实战_13720859(1)》PDF版.pdf63《PYTHON数据可视化编程实战13720859》PDF版.pdf64《Python网络编程基础》PDF版.pdf65《Python网络数据采集》PDF版.pdf66《Python学习手册(第4版)》PDF版.pdf67《Python学习手册（第3版）》PDF版.pdf68《Python学习手册（第4版）》PDF版.pdf69《python 学习资料 》PDF版.pdf70《Python语言及其应用》PDF版.pdf71《Python语言入门》PDF版.pdf72《Python源码剖析-深度探索动态语言核心技术》PDF版.pdf73《Scikit－Learn教學：Python_與機器學習（Article）》PDF版.pdf74《Selenium 2自动化测试实战 基于Python语言》PDF版.pdf75《TensorFlow实践与智能系统》PDF版.pdf76《Tensorflow 实战Google深度学习框架》PDF版.pdf77《wxPython实战(中文版）》PDF版.pdf78《白话深度学习与TensorFlow》PDF版.pdf79《贝叶斯思维统计建模的PYTHON学习法》PDF版.pdf80《笨办法学 Python(第四版）》PDF版.pdf81《编程小白的第一本python入门书》PDF版.pdf82《编写高质量代码 改善Python程序的91个建议》PDF版.pdf83《常用数据挖掘算法总结及Python实现》PDF版.pdf84《从Excel到Python——数据分析进阶指南》PDF版.pdf85《从Python开始学编程》PDF版.pdf86《大数据交易区块链技术应用标准》PDF版.pdf87《机器学习numpy和pandas基础》PDF版.pdf88《机器学习实战》PDF版.pdf89《基于Python实现的微信好友数据分析》PDF版.pdf90《简明Python教程（#）》PDF版.pdf91《精通Python设计模式带索引书签目录》PDF版.pdf92《精通比特币》PDF版.pdf93《可爱的Python脚本语言入门精品文章》PDF版.pdf94《利用Python进行数据分析(###)》PDF版.pdf95《量化投资以Python为工具》PDF版.pdf96《流畅的python》PDF版.pdf97《轻量级Django_，Julia_Elman_，P218_，2016.10》PDF版.pdf98《区块链：互联网的诗和远方》PDF版.pdf99《区块链 从数字货币到信用社会》PDF版.pdf100《区块链革命》PDF版.pdf101《区块链行业词典-甲子光年+维京资本 2018.02》PDF版.pdf102《区块链技术-在线教育共享生态的基石》PDF版.pdf103《区块链技术——通往未来的虫洞》PDF版.pdf104《区块链 将如何重新定义世界》PDF版.pdf105《区块链社会》PDF版.pdf106《区块链 新经济蓝图及导读》PDF版.pdf107《社交网站的数据挖掘与分析_中文版》PDF版.pdf108《深度学习-无水印-中文版》PDF版.pdf109《深入Python3中文版》PDF版.pdf110《数据结构与算法Python语言描述裘宗燕编著北京：机械工业出版社_，_2016.01_P346》PDF版.pdf111《数据科学入门(1)》PDF版.pdf112《数据科学入门》PDF版.pdf113《腾讯区块链白皮书》PDF版.pdf114《图说区块链，区块链革命，区块链社会，区块链技术驱动金融，区块链重塑经济与世界6本》PDF版.pdf115《图说区块链》PDF版.pdf116《网络爬虫－Python和数据分析》PDF版.pdf117《以太坊白皮书（中文）》PDF版.pdf118《用Python进行自然语言处理(中文翻译NLTK)》PDF版.pdf119《用Python写网络爬虫》PDF版.pdf121《与孩子一起学编程（第一版）》PDF版.pdf122《征服PYTHON-语言基础与典型应用》PDF版.pdf123《中国区块链技术和应用发展白皮书》PDF版.pdf ** 百度网盘链接：https://pan.baidu.com/s/1yujN2BoaObDJYBFKqcghkg提取码：9c4n]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之快速排序的求解策略《五》]]></title>
    <url>%2F2018%2F09%2F04%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E4%BA%94%2F</url>
    <content type="text"><![CDATA[一.快速排序的基本思想:通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。 二.快排的平均运行时间复杂度是:O(nlog(n))。快速排序最坏的时间复杂度是O(n^2）== 冒泡排序最坏时间复杂度也是O(O^2)。 三.3种实现方法 ①固定基准元法 【如果输入序列是随机的，处理时间是可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。 因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2)。 而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为基准元是非常糟糕的，应该立即放弃这种想法。】 ②随机基准元 【这是一种相对安全的策略。 由于基准元的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。 在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。 实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。 所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度】 ③三数取中【引入的原因：虽然随机选取基准时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2）， 要缓解这种情况，就引入了三数取中选取基准。】 四.总结分析： 最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。 可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准元而得到。 事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准元。 显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约5%的比较次数。 五.补充总结 下面代码中 arry[left]可以换为arry[left+(right-left)/2] 实质也就是三值取中法，时间复杂度相对比arry[left]会减少很多。 下面是一个1000个随机的数，可以作为参考数据。 java版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;public class quickSortAlgorithm1 &#123; public static void main(String[] args)&#123; long startTime = System.currentTimeMillis(); //获取开始时间 int[] num=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;; //int[] num=&#123;6,1,2,7,9,3,4,5,10,8&#125;; SortUtils.quickSort(num, 0, num.length-1); System.out.println(Arrays.toString(num)); long endTime = System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间：" + (endTime - startTime) + "ms"); //输出程序运行时间 &#125;&#125;class SortUtils&#123; public static void quickSort(int arry[],int left,int right) &#123; if(left&gt;=right) &#123;//当递归到left（初始值是0）都大于right（初始值是数组长度减一）时候，返回这个数组 return; &#125; // 【重大提醒：基准数的选取对算法的复杂度影响很大，这里采用三值取中法。随机数法看人品。最糟糕就是取第一个数为基准数。】具体见上面特别分析 int p=arry[left];//基准数，后面p等价于数组最左边的数 int i=left,j=right;//i是最左边的数的下标，j是最右边的数的下标 while(i!=j) &#123;//当i不等于j时候，循环下面的操作，也就是说 当i和j相等即相遇的时候，跳出来。 while(arry[j]&gt;=p&amp;&amp;i&lt;j) &#123;//当数组的第j个下标的数大于基准数时（i必须小于j） j--;//j减减 &#125; while(arry[i]&lt;=p&amp;&amp;i&lt;j) &#123;//当数组的第i个小标的数小于基准数时（i必须小于j） i++;//i加加 &#125; //经过上面的操作数组i和j的下标的数都已经各自大于基准数和小于基准数 if(i&lt;j) &#123; //这个时候，就要交换这两个下标的数 int temp=arry[i];//交换两个数 arry[i]=arry[j]; arry[j]=temp; &#125; &#125; //实质是以6位基准数的最后一次交换数字，之后以这个基准数的左边和右边分别递归。 arry[left]=arry[i];//交换基准数1 arry[i]=p;//交换基准数2 quickSort(arry, left, i-1);//选择这个数组原来的基准数的左边进行递归。 quickSort(arry, i+1, right);//选择这个数组原来的基准数的右边进行递归。 &#125;&#125; C语言版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int a[10]=&#123;6,1,2,9,7,4,5,10,8&#125;;//1.首先全局变量定义一个数组int a[1000]=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;;//2.快排函数的三个实参是待快排的数组，//该数组的最左边的下标，该数组最右边的下标。void quickSort(int *arr,int left,int right)&#123; //3.定义i为左哨兵,j为右哨兵,p为基准兵(当前数组的基准兵为当前数组的左哨兵下标的值)看下图示 //6,1,2,9,7,4,5,10,8 //基准哨兵:p //左右哨兵:i j int i=left,j=right,p=arr[left]; //4.左下标大于等于右下标也就是快排排好的时候 if(left&gt;=right)&#123; return; &#125; while(i != j)&#123; while(arr[j]&gt;=p&amp;&amp;i&lt;j)&#123; j--; &#125; while(arr[i]&lt;=p&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; int temp ; temp =arr[i]; arr[i] =arr[j]; arr[j] =temp; &#125; &#125; arr[left] =arr[i]; arr[i] = p; quickSort(arr,left,i-1); quickSort(arr,i+1,right); &#125;int main()//1.写主函数&#123; int i; quickSort(a,0,999);//调用快排函数 for (i=0;i&lt;1000;i++)&#123; printf("%d\n",a[i]);//输出结果，codeblock先ctrl+F11编译，再ctrl+F10运行； &#125; return 0;&#125; 快速排序推荐阅读博客：http://developer.51cto.com/art/201403/430986.htm https://blog.csdn.net/liuyi1207164339/article/details/50827608 https://www.cnblogs.com/surgewong/p/3381438.html http://www.cnblogs.com/foreverking/articles/2234225.html https://www.cnblogs.com/y3w3l/p/6444837.html https://blog.csdn.net/liuzhenya1994/article/details/80254958]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之约瑟夫环问题求解策略《四》]]></title>
    <url>%2F2018%2F08%2F30%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.ArrayList;/** * 约瑟夫环 问题 * 获取幸运数字 * 思路： * ①集合数组的 * ②递归 */public class josephRing03 &#123; public static void main(String[] args)&#123; System.out.println("第一种方法：集合法"); System.out.println(getLuckNum01(10)); System.out.println("第二种方法：递归法"); System.out.println(getLuckNum02(10,3,8)); System.out.println(getLuckNum02(9,3,7)); System.out.println(getLuckNum02(8,3,6)); System.out.println(getLuckNum02(7,3,5)); System.out.println(getLuckNum02(6,3,4)); System.out.println(getLuckNum02(5,3,3)); System.out.println(getLuckNum02(4,3,2)); System.out.println("第三种方法：公式法");//本质也是递归 System.out.println(getlive(10, 3)); System.out.println(getlive( 9, 3)); System.out.println(getlive( 8 , 3)); System.out.println("第三.001种方法：公式形象记忆法");//本质也是递归 System.out.println(getLuckNum(10, 3)); System.out.println(getLuckNum(9, 3)); System.out.println(getLuckNum(8, 3)); &#125; //①数组集合法 public static int getLuckNum01(int num) &#123; //1.定义一个集合，并且添加人进去，10环就add十个人进去，100人环就add100个人进去 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= num; i++) &#123; list.add(i); &#125; //2.定义一个指针，区别于下面的i，这个count是直接跟人头对接的，所以要从1开始。 int count = 1; //3.遍历所有元素，一直“杀死”人直到只剩下最后一个人即list.size()!=1时都要继续遍历 /* System.out.println(list.size());*/ for (int i=0;list.size()!=1;i++)&#123; //4.如果已经遍历到最后一个人了，则重新开始，i重新等于0,又一个新环来进行“杀人”游戏 //注：这里要设置判断条件为list.size(),而不是list.size()-1是有原因的 //因为i作为下标一直遍历增加，直到最后一个下标，都是可以杀人的， //也就是说还可以进行下面的if判断以及count++ //所以，直到i增加到list.size时，已经可以说是下标越界了 //此时就要使得要越界的这个i变成0，重新开始新的“i生”（人生~哈哈哈） if(i==list.size())&#123; i =0; &#125; //5.当指针的对3求余为0时，去除掉list的这个元素。 //注：由于少了一个数，后面的数会补上前来，下标不变的话，i又必须得-1，才能不会错过当前的人 if(count%3 == 0)&#123; list.remove(i--); &#125; //6.count继续累加 count++; &#125; return list.get(0); &#125; //②递归法（大神法） public static int getLuckNum02(int sum,int value,int n) &#123; if( n ==1)&#123; return (sum+value-1)%sum; &#125; else&#123; return (getLuckNum02(sum-1, value, n-1)+value)%sum; &#125; &#125; //3.公式法 public static int getlive(int n,int m)&#123; if(n == 1)&#123;return 1;&#125; return (getlive(n-1,m)+m-1)%n+1;//背下来就可以了 &#125; //3.01形象记忆公式法 public static int getLuckNum(int sumMan,int jiange)&#123; if(sumMan == 1) &#123; return 1; &#125; else&#123; return (getLuckNum(sumMan-1,jiange)+jiange-1)%sumMan+1;//背下来就可以了 &#125; &#125;&#125; 总结： ①直接背公式。 ②理解指针指向。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之求长整数中所有0和尾数0的个数的策略《三》]]></title>
    <url>%2F2018%2F08%2F29%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%B1%82%E9%95%BF%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%80%E6%9C%890%E5%92%8C%E5%B0%BE%E6%95%B00%E7%9A%84%E4%B8%AA%E6%95%B0%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89%2F</url>
    <content type="text"><![CDATA[/** 求出：1000的阶乘所有零和尾部零的个数，不用阶乘。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.math.BigInteger;public class test1000For002 &#123; public static void main(String[] args)&#123; //错误方案： //demo01();1000阶乘远大于long的类型范围,行不通。 //正确方案： //calculateTheNumOfZeroTest01(); 求出这个大数字中所有0的个数 //calculateThelastZeroNum02(); 求出这个大数字中尾部0的个数 &#125; public static void calculateThelastZeroNum02() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; String string2 =b1.toString(); StringBuilder sb2 = new StringBuilder(string2); string2 =sb2.reverse().toString();//链式编程，反转字符串再赋值 int count2=0; for (int i = 0; i &lt;string2.length() ; i++) &#123; if('0'==string2.charAt(i))&#123; count2++; &#125; else &#123; break; &#125; &#125; System.out.println(count2);//249 &#125; public static void calculateTheNumOfZeroTest01() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; // System.out.println(b1); String string =b1.toString(); int count=0; /* char[] arr =string.toCharArray();*/ for (int i = 0; i &lt;string.length() ; i++) &#123; if('0' == string.charAt(i))&#123; count++; &#125; &#125; System.out.println(count); &#125; public static void demo01() &#123; long num =1; for(long i=1; i &lt;= 1000;i++)&#123; num =i * num; &#125; System.out.println(num); &#125;&#125; 总结：①当需求的数的个数超过int和long的类型的最大长度时，即2^32-1这个值时，可以利用java自带的类库BigInterger对数字进行字符串化并且利用类的方法进行求值。②考虑到求尾数0的个数，当看到求【尾数类】的题目时，要想到String中没有直接倒过来的方法，要把String放入StringBulidedr中，再利用StringBulider的方法对其进行反转，思路就开了。③链式编程了解一下emmm。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之斐波那契数列题型两种解题策略《二》]]></title>
    <url>%2F2018%2F08%2F28%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%A2%98%E5%9E%8B%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/**不死神兔 月月生问题 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 两种解题思路： ①利用数组 ②递归计算 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* *不死神兔 月月生问题 * 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 * 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 * 两种解题思路： * ①利用数组 * ②递归计算 */public class rabbitTest01 &#123; public static void main(String[] args)&#123; // ①利用数组(7行代码搞定) getRabbitNum01(); //②递归计算(2行代码搞定) //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.利用递归输出,核心是:fun(num) =fun(num-2)+fun(num-1); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+getNum(i+1)+"只"); &#125; &#125; public static int getNum(int i)&#123;//利用三元运算符使代码更简洁 return (i ==1||i ==2) ? 1 :(getNum(i-2)+getNum(i-1)); &#125;/*下面小测试的答案在这里：第10个月————21对大兔子生下21对小兔子————————13对小兔子长成13对大兔子 ——共55对（42+13）你做对了么?对了就请点个喜欢吧~~~*/ public static void getRabbitNum01() &#123; //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.初始化第一和第二个元素为1 arr[0]=arr[1]=1; //3.遍历一下这个数组，也就是让每个月都有个兔子总数值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i-2] +arr[i-1]; &#125; //4.选择输出每个月份的兔子总数，直观清晰 for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+arr[i]+"只"); &#125; &#125;&#125; 总结：规律掌握如下，一点点理解，这个不会太难。月份——————兔子生长情况——————兔子当月总对数第1个月————1对小兔子———————— 共1对第2个月————1对大兔子———————— 共1对第3个月————1对大兔子生下1对小兔子——共2对（1+1）第4个月————1对大兔子生下1对小兔子————————1对小兔子长成1对大兔子 ——共3对（1+2）第5个月————2对大兔子生下2对小兔子————————1对小兔子长成1对大兔子 ——共5对（2+3）第6个月————3对大兔子生下3对小兔子————————2对小兔子长成2对大兔子 ——共8对（6+2）第7个月————5对大兔子生下5对小兔子————————3对小兔子长成3对大兔子 ——共13对（10+3）第8个月————8对大兔子生下8对小兔子————————5对小兔子长成5对大兔子 ——共21对（16+5）第9个月————13对大兔子生下13对小兔子————————8对小兔子长成8对大兔子 ——共34对（26+8）小测试：看你懂了没？第10个月————？对大兔子生下？对小兔子————————？对小兔子长成？对大兔子 ——共？对（？+？）答案藏在本篇文章中，聪明人10秒钟内应该能看到。或者，自己把代码敲一遍，结果自然明白。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之二分查找题型的解题策略《一》]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A2%98%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 二分查找： 查找元素对应的索引 前提：数组有序，这点特别重要！！！要求的数组一定要按照顺序来的。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546package day13.searchAlgorithm;public class binarySearch &#123; public static void main(String[] args)&#123; int[] arr = &#123;11,22, 33, 44, 55&#125;; System.out.println(binarysearch(arr,11)); System.out.println(binarysearch(arr,22)); System.out.println(binarysearch(arr,33)); System.out.println(binarysearch(arr,44)); System.out.println(binarysearch(arr,55)); System.out.println(binarysearch(arr,66)); System.out.println(binarysearch(arr,77)); &#125; private static boolean binarysearch(int[] arr, int num) &#123; /** * 二分查找3点 * 1.确定 小中大 3个索引 * 2.判断 中索引 的值是否等于 待查值，等于即返回true，不等于进入while循环 * 3.判断 值的索引与中的索引的大小， 中大就大索引改为中大索引-1， 中小就小索引改为中大索引+1， 中大索引本身改为大小索引之和的一半 * 4.当小索引大于大索引时返回false */ int max = arr.length - 1; int min = 0; int mid = (max + min) / 2; Boolean flag; while (arr[mid]!=num) &#123; //当中间值 mid = (max + min) / 2; if (arr[mid] &gt; num) &#123; max = mid - 1; &#125; else if (arr[mid] &lt; num) &#123; min = mid + 1; &#125; if(min&gt;max)&#123; return false; &#125; &#125; return true; &#125;&#125; 总结：二分查找关键在于数组中数字要有序，其次是确定好三个索引的大小关系。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16分钟教你搭建一个Hexo博客>]]></title>
    <url>%2F2018%2F08%2F10%2FHexo%E6%90%AD%E5%BB%BAnext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8F%82%E8%80%83001%2F</url>
    <content type="text"><![CDATA[目的：搭建一个hexo.next主题的博客 用时：大约要16分钟左右 条件：①一个git-bash命令行窗口②一个npm打包工具③一个node.js运行环境④一个gitHub账号]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铭戈栈]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%93%AD%E6%88%88%E6%A0%88%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法：①标题大小 铭戈栈的第一篇博客markDown语法###②大小列表 java a IDE的选择 b 数据类型 c 数组 d 类文件 .class和.java的区别 e String类的使用 c++ 算法 ③引用外链第一种java博客学习对象第二种（优先）java博客学习对象 ##改字体④斜体字/这个字好像是斜体的！！/⑤删除字这是加删除线的文字⑥加粗这是加粗的文字⑦斜体加粗这是斜体加粗的文字 ##插入东西 三个横线： ##引用图片： ##代码区：1234567&lt;html&gt; &lt;title&gt; 我是标题 &lt;/title&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; ##引用区 第一个引用 第二个引用]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>目录</tag>
        <tag>个人简介</tag>
      </tags>
  </entry>
</search>
