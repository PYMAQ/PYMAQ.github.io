<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[架构师之路史诗级必读书单吐血整理四个维度系列80+本书(珍藏版)]]></title>
    <url>%2F2018%2F10%2F24%2FToCoder%2F</url>
    <content type="text"><![CDATA[互联网行业的特点是变化。若要提高互联网开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。 以下就给想要成为架构师的程序猿们推荐从事技术生涯这一辈子都要花时间去看的书单，以及一份技术书阅读方法论总结： 前言：技术书阅读方法论一.速读一遍（最好在1~2天内完成）人的大脑记忆力有限，在一天内快速看完一本书会在大脑里留下深刻印象，对于之后复习以及总结都会有特别好的作用。 对于每一章的知识，先阅读标题，弄懂大概讲的是什么主题，再去快速看一遍，不懂也没有关系，但是一定要在不懂的地方做个记号，什么记号无所谓，但是要让自己后面再看的时候有个提醒的作用，看看第二次看有没有懂了些。 二.精读一遍（在2周内看完）有了前面速读的感觉，第二次看会有慢慢深刻了思想和意识的作用，具体为什么不要问我，去问30年后的神经大脑专家，现在人类可能还没有总结出为什么大脑对记忆的完全方法论，但是，就像我们专业程序员，打代码都是先实践，然后就渐渐懂了过程，慢慢懂了原理，所以第二遍读的时候稍微慢下来，2周内搞定。记住一句话：没看完一个章节后，总结一下这个章节讲了啥。很关键。 三.实践（在整个过程中都要）实践的时候，要注意不用都去实践，最好看着书，敲下代码，把重点的内容敲一遍有个肌肉记忆就很不错了。这个过程最好结合”费曼思想”进行思考，反思，总结。当然如果能把刚刚学习到的内容结合现在做的项目‘注入’，即即学即用，效果甚佳。 以及到自己做过的项目中去把每个有涉及的原理的代码，研究一遍，就可以了 网盘下载链接架构师之路史诗级必读书单吐血整理四个维度系列80+本书链接：https://pan.baidu.com/s/1H1et7CxdjyATyERQDBGvnQ提取码：1kez备注：文件比较大，网盘直接打开会显示损坏，里面已经整理并且压缩好，需要下载后才可以打。 资源图示： 想要成为架构师的程序员一生必读的书，分为以下四个部分：1.Coding Practice(编程实践系列)2.Architecture Design(架构与设计系列)3.Methodology(方法学系列)4.Thought Leadership(思想与领导力系列)5.奇门遁甲系列6.互联网大佬奇迹传记系列： 架构师一生必读书籍推荐理由：一.编程实践系列：1 《代码整洁之道》 推荐理由:《代码整洁之道》讲述了一系列行之有效的整洁代码操作实践。软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。《代码整洁之道》提出一种观念：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，这些实践在《代码整洁之道》中体现为一条条规则(或称“启示”)，并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。 2 《卓有成效的程序员》 垂涎这本书很久，终于花了一天时间看完了。本书所介绍的最主要的不是工具和方法，而是思想，有助于我们提升工作效率的思想。工具和方法是其次的，只要理解掌握这些思想，并在实际工作中运用到，就能够大大提升我们的工作效率了。总的来说，这本书还是很优秀的，是一本「集大成」的书籍。里面很多想法和概念通过阅读其他书籍也能接触到，只不过在这本书里面，作者结合自己的亲身经验总结来介绍，更有助于理解这些想法。在我看来，整本书一直都在灌输着三个思想：一、经典的还是好的二、尽量把事情交给计算机来完成作者有句话我是很赞同的：只要做过一次的事情，以后很大程度要重复做。三、选择最合适的，而不是追求最好的。 3 《程序员的职业素养》 Robert C.Martin的大名咱就不说啥了。这本书写的深入浅出，感觉像读一本小说，流畅自然，但自然而然的就学到了很多东西。结合工作经验，常有种“确实如此”的感觉。该书尤其适合我等初入职场，试图成为“专业人员”的人。其中永远不要说“我试试”和有关测试的章节给我留下了深刻印象。 4 《重构与模式》 只是看了一半，因为其中每个例子都含有作者实践过的真实代码，非常适合我们跟着作者的思路去思考，运用设计模式进行重构，解决眼前存在的难题！ 5 《代码大全》 初见《代码大全》，还是该书的第一版，只从书名上看，还以为都是一些代码的示例。觉得还有很多的书需要读，这种实用主义的技巧书，可以先放一放，于是与之失之交臂。及至后来，才发现原来被中文书名给骗了。只要将目录浏览一过，就会发现，这本书基本覆盖了软件构建的全过程，从需要分析、系统架构设计到具体的编码规范、编码技巧，程序员可以在其中找到所有想找到的内容。而且每一个方面作者都进行了深入的探讨和详细的解说，同时也给出了想要更进一步学习的参考。可以说，这是一本对其出版之前的所有软件构建的知识的百科全书。对于争论较多的方面，作者给出了较为合理、公允的折中方案，甚至在34章最后一节”汝当分离软件与信仰“，作者明确的阐述了这一思想。这本书和《程序员修炼之道》一厚一薄，相映成趣，都是难得一见的好书，值得花时间和精心用心的阅读，并不时拿出来温习，可以肯定的是，每次翻开，必有收获！ 6 《实现模式》 这是一本关注程序细节并具有浓厚实战意义的书籍, 它主要是来告诉我们如何写出容易让人理解的代码. 如果非要在书名前加一个限定词的话, “java实现模式”可能更贴切一些, 因为里面的代码都是以java作为例子来说明的. 作者是junit的贡献者之一, 因此里面的很多例子都是从junit中来的.这本书也解决了很多自己在实际开发中的一些抉择困惑. 是一本非常值得常看的书籍. 另外翻译的也非常不错, 不像有些书让人看了云里雾里的, 不知所云.本书按照方法, 行为, 类, 状态, 集合, 框架的顺序依次对相关的实现模式加以说明来阐述如何写出好的代码. 也是本书的重点, 集合主要是在讲java.util下的集合类的使用法则, 框架部分主要是框架的开发有自己的规则, 围绕兼容性, 扩展性方面在说事儿。 7 《程序员修炼之道》 很久以前买的这本书，忘记在哪里看到这部书的推荐了，有大牛很卖力的推荐，于是去买了一本。坦白讲，那个时候自己是完完全全的菜鸟，从大学里出来，除了会编程啥也不懂，这本书在当时真的是指路明灯。书中的道理很浅显，可是对于菜鸟却是至理名言。基本为你勾勒了一个成熟软件程序员专家所需要的所有特性。我自觉地获益颇多，其中很多事情，要么在当时是自己没有想到的，要么是发生了，自己没有注意的等等。给我影响很大。当然，有些自以为是的”大牛”是鄙视这些的，因为看起来不够高深，随便吧，反正它讲的是从小工到专家，我是从小工过来的，那些凭空冒出来的“专家”不看也罢。 8 《高性能MySQL》 书很厚，内容非常全面，基本涵盖了所有使用中需要了解的基础和进阶知识，认真看完基本就没有知识死角了书的语言风格和内容编写都非常好，没有废话，全书无任何尿点，每一节每一段话都很重要,作者们是mysql DBA届的大牛，经验和知识水平没得说，尤其让人如沐春风的是作者的一些谆谆教诲，大师风范跃然纸上国内tb大牛翻译的也很棒。非常好的一本书，五星力荐，即使你不是DBA也值得一读。稍微美中不足的就是知识的深度上有所欠缺，很多知识点讲出来了，但是背后的原理却没有触及，当然这和本书偏向应用的定位有关 9 《修改代码的艺术》 这本书很薄，但是看起来还是很吃力，里面介绍了很多重构的知识，而且有很多c++的内容，有的地方也是似懂非懂的，如果了解设计模式和重构，就会轻松很多，可能艺术这东西，本身就不容易懂吧。里面对单元测试的依赖性很强，其实还是一本不错的书，你完全可以领略到作者真的把代码的修改看成是一种艺术，软件工程师要做到匠人的地步也着实不容易。看得出写代码不是一件简单的事情，是需要经验的，不像国内这样，写代码是年轻人的事情，其实没有时间的锤炼是写不出好的代码来的，即使写出来也不能谈得上是艺术了。希望将来再次翻起这本书时会有更多的领悟。 10 《计算机程序的构造和解释》 这是一本很有趣的书，任何对编程真正感兴趣的人都应该看看。它讲了程序结构的很多方面，但始终围绕着一个主题，那就是从各个层次上来减少计算的复杂度。这和我读过的另外几本书核心是一样的，只是维度不同。比如《代码大全》厚厚的一本书讲的也是管理复杂度（http://book.douban.com/review/4981648/），但是它针对的是软件工程这门工作该从哪些方面来提高生产效率，减少沟通和维护的成本，比如变量名该怎样起，函数该多长，注释该怎么写。而这本书的出发点是各种编程问题，重点放在该如何分层以减少程序的复杂度，有点像是《Head First设计模式》，讨论的也是如何封装变化，针对接口编程等等，不过《SICP》里的问题难得多而已，类似算法一样很费脑筋。 11 《重构：改善既有代码的设计(中文版)》 Martin Fowler 的《重构-改善既有代码的设计》这本书，是我大学老师推荐给我的。 当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000+行）， 就会逐渐失去对代码的控制能力。这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书， 将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。 12 《调试九法——软硬件错误的排查之道》 一般当工程师把一个东西称为艺术甚至玄学的时候，说明这个东西难度很大，没有太多规律可以遵循，调试就属于此列。几乎每个程序员都有被bug搞到死去活来的经验，有时候颠来倒去，问题似乎解决了，但也不知道为什么，就把它当作不可解释的玄学现象，最烦人的一种bug是偶尔出现难以复现的，学名海森堡bug。不过毕竟软件还是属于科学技术的范畴，调试也应当是门技术活。《调试九法》是一本少见的讲调试技术的书，九个普遍性的原则不仅适用于软硬件开发维护，甚至还能运用到日常生活，为了找到这本书我也是费了点神，幸好图灵社区还有正版的电子书卖。说实话，作者举的很多例子偏硬件，所以理解起来有点隔膜，但是九个原则确实很实用，在我以前的开发调试经历中可能也不自觉的总结过一些，但是看了本书，还是有拿到武功心法的感觉。 13 《算法设计与分析基础第3版》 对算法做了一个很新颖的划分，可以看到它和我们经常看的算法书的知识点划分很不一样。作者得归类很不错。对一些常用思想做了分类。比如作者对分治做了几个分类。纯思维层面的切入分析，而不像以前的分为一般算法和图论那样子。书中有不错的习题。思想描述有一定的思维引导性质。 14 《实用J2EE设计模式编程指南》 从应用的层次看来。从价格和其本身的内容这个角度来比较的话，这本书还是很划算的。其前1/3的对设计模式的总结还是十分清晰的。而后面的相当多的关于EJB的内容就是根据读者的需要来看了。 15 《编写可读代码的艺术》 姑且不谈该书中提到的程序最优与否，本书在给广大的程序员上了一堂关键的编程品德学。就如同科学发展到一定程度出现对科学家应该具有什么品德展开讨论一样，本书也提出了作为一个出色的、有责任心的程序员应该具有的品质——让他人更容易看懂自己的代码。从个人经验来谈，身边很多人编程时都是考虑如何完成程序的使命，很少有人去考虑别人是否看得懂。结果造成当别人看你程序时看不懂，问你你又不耐烦讲这种局面数不胜数。本书从根本上——即编程的基本思想层面，告诉广大编程的人要具有编程的责任感，方便大家的同时才能方便自己。所以该书对程序员在思想启蒙上是一本不可多得的好书。 16 《大话设计模式(带目录完整版)》17 《程序设计方法》18 《七周七语言：理解多种编程范型》19 《程序设计语言——实践之路》20 《程序设计实践中文版》21 《编码：隐匿在计算机软硬件背后的语言（美）佩措尔德》22 《编程原本》二.架构与设计系列：1 《敏捷软件开发：原则、实践与模式》2 《深入浅出设计模式》3 《Unix编程艺术》4 《企业应用架构模式》5 《领域驱动设计.软件核心复杂性应对之道.软件核心复杂性应对之道》6 《企业集成模式：设计、构建及部署消息传递解决方案》7 《架构之美》8 《面向模式的软件架构_卷5_模式与模式语言》9 《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》10 《领域特定语言》11 《元素模式》12 《设计模式：可复用面向对象软件的基础》13 《设计模式：Java语言中的应用》14 《编程珠玑（第2版）（第一部）》15 《编程珠玑(编程珠玑续篇)（第二部）》16 《淘宝技术这十年 完整版》17 《软件架构的艺术》（简称架构之美）18 《软件框架设计的艺术》19 《软件测试的艺术(原书第2版）》20 《HeadFirst设计模式》21 《编程语言实现模式》三.方法学系列：1 《用户故事与敏捷方法完整中文版》2 《金矿：精益管理 挖掘利润 （法）伯乐著》3 《[解析极限编程：拥抱变化（原书第2版）》4 《持续交付-发布可靠软件的系统方法完整版》5 《重构极限编程 XP的实践与反思》6 《系统化思维导论》7 《程序员的思维修炼：开发认知潜能的九堂课》8 《程序员的思维修炼：开发认知潜能的九堂课》9 《禅与摩托车维修艺术 罗伯特·M·波西格》10 《人月神话》四.思想与领导力系列：1 《卓有成效的管理者》2 《你的灯亮着吗》3 《成为技术领导者》4 《第五项修炼》5 《思考快与慢》6 《麦肯锡方法》五.奇门遁甲系列：1 《软件调试的艺术》2 《世界是数字的.Brian.W.Kernighan》3 《极客与团队》4 《计算的本质：深入剖析程序和计算机》5 《计算机科学概论（原书第3版）》6 《计算机系统概论》7 《人件（原书第3版）》8 《深入理解计算机系统》六.互联网大佬奇迹传记系列：1 《史蒂夫·乔布斯传》2 《沃兹传：与苹果一起疯狂》3 《沃兹传：与苹果一起疯狂》4 《苹果首席设计师_乔纳森传》5 《雷军：人因梦想而伟大》6 《马云传》7 《企鹅凶猛：马化腾的中国功夫》8 《拒绝平庸 周鸿祎和他的创士记》9 《比尔盖茨全传》10 《阿桑奇自传》11 《马云：我的成功不是偶然，给年轻人的创业课.任雪峰》12 《编程人生_15位软件先驱访谈录》13 《史玉柱自述：我的营销心得》14 《一网打尽贝佐斯与亚马逊时代》15 《世界因你不同：李开复自传》16 《编程大师访谈录》17 《DOOM启世录》18 《奇思妙想：15位计算机天才及其重大发现》19 《孵化Twitter 从蛮荒到IPO的狂野旅程》 网盘下载链接架构师之路史诗级必读书单吐血整理四个维度系列80+本书链接：https://pan.baidu.com/s/1H1et7CxdjyATyERQDBGvnQ提取码：1kez备注：文件比较大，网盘直接打开会显示损坏，里面已经整理并且压缩好，需要下载后才可以打。 总结：天下没有不劳而获的果实，望各位年轻的朋友，想学技术的朋友，在决心扎入技术道路的路上披荆斩棘，把书弄懂了，再去敲代码，把原理弄懂了，再去实践，将会带给你的人生，你的工作，你的未来一个美梦。 附Java学习之路吐血整理技术书从入门到进阶最全50+本（珍藏版)：https://pymlovelyq.github.io/2018/10/26/java/python从入门到进阶推荐书籍最全整理pdf分享附网盘链接已拿BT豆瓣offer：https://pymlovelyq.github.io/2018/10/20/python/Web前端书单从HTML到JS到AJAX到HTTP从框架到全栈过来人帮你走更少弯路（珍&gt;藏版）：https://pymlovelyq.github.io/2018/10/17/WebFont/机器学习和python学习之路吐血整理技术书从入门到进阶(珍藏版)：https://pymlovelyq.github.io/2018/10/15/machineLearning/学习数据库从入门到进阶书籍pdf版吐血整理推荐（珍藏版：https://pymlovelyq.github.io/2018/10/12/database/C语言推荐书籍从入门到进阶带你走上大牛之路（珍藏版）：https://pymlovelyq.github.io/2018/10/10/CC/算法与数据结构+一点点ACM从入门到进阶吐血整理推荐书单（珍藏版）：https://pymlovelyq.github.io/2018/10/06/Algorithm/安卓入门到进阶推荐书籍整理pdf附网盘链接已拿阿里豆瓣offer(珍藏)：https://pymlovelyq.github.io/2018/09/04/An/]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>程序员</tag>
        <tag>传记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之汉诺塔求解策略《六》]]></title>
    <url>%2F2018%2F09%2F06%2FjavaForSix%2F</url>
    <content type="text"><![CDATA[java版汉诺塔1234567891011121314151617181920212223242526272829public class Hanoi &#123; public static void main(String[] args)&#123; Hanoi.hanoi(3,'A','B','C'); &#125; public static void hanoi(int n,char a,char b,char c)&#123; ZF z = new ZF(); if(n==1)&#123; print(a,c); &#125; else&#123; hanoi(n-1,a,c,b); print(a,c); hanoi(n-1,b,a,c); &#125; System.out.println("---------第"+(ZF.x++)+"次递归---------------------------------"); &#125; public static void print(char a,char c)&#123; System.out.println("盘子从"+a+"---&gt;"+c); &#125;&#125; class ZF &#123; static public int x=1;&#125;//思想是将全局变量X设置成SS类的属性，//再在SS中添加fuzhi方法，来改变X的值。 汉诺塔求解推荐阅读博客：https://www.bilibili.com/video/av7398130/https://blog.csdn.net/xb2355404/article/details/79144451https://www.cnblogs.com/antineutrino/p/3334540.html]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之快速排序的求解策略《五》]]></title>
    <url>%2F2018%2F09%2F04%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E4%BA%94%2F</url>
    <content type="text"><![CDATA[一.快速排序的基本思想:通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。 二.快排的平均运行时间复杂度是:O(nlog(n))。快速排序最坏的时间复杂度是O(n^2）== 冒泡排序最坏时间复杂度也是O(O^2)。 三.3种实现方法 ①固定基准元法 【如果输入序列是随机的，处理时间是可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。 因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2)。 而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为基准元是非常糟糕的，应该立即放弃这种想法。】 ②随机基准元 【这是一种相对安全的策略。 由于基准元的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。 在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。 实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。 所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度】 ③三数取中【引入的原因：虽然随机选取基准时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2）， 要缓解这种情况，就引入了三数取中选取基准。】 四.总结分析： 最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。 可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准元而得到。 事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准元。 显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约5%的比较次数。 五.补充总结 下面代码中 arry[left]可以换为arry[left+(right-left)/2] 实质也就是三值取中法，时间复杂度相对比arry[left]会减少很多。 下面是一个1000个随机的数，可以作为参考数据。 java版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;public class quickSortAlgorithm1 &#123; public static void main(String[] args)&#123; long startTime = System.currentTimeMillis(); //获取开始时间 int[] num=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;; //int[] num=&#123;6,1,2,7,9,3,4,5,10,8&#125;; SortUtils.quickSort(num, 0, num.length-1); System.out.println(Arrays.toString(num)); long endTime = System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间：" + (endTime - startTime) + "ms"); //输出程序运行时间 &#125;&#125;class SortUtils&#123; public static void quickSort(int arry[],int left,int right) &#123; if(left&gt;=right) &#123;//当递归到left（初始值是0）都大于right（初始值是数组长度减一）时候，返回这个数组 return; &#125; // 【重大提醒：基准数的选取对算法的复杂度影响很大，这里采用三值取中法。随机数法看人品。最糟糕就是取第一个数为基准数。】具体见上面特别分析 int p=arry[left];//基准数，后面p等价于数组最左边的数 int i=left,j=right;//i是最左边的数的下标，j是最右边的数的下标 while(i!=j) &#123;//当i不等于j时候，循环下面的操作，也就是说 当i和j相等即相遇的时候，跳出来。 while(arry[j]&gt;=p&amp;&amp;i&lt;j) &#123;//当数组的第j个下标的数大于基准数时（i必须小于j） j--;//j减减 &#125; while(arry[i]&lt;=p&amp;&amp;i&lt;j) &#123;//当数组的第i个小标的数小于基准数时（i必须小于j） i++;//i加加 &#125; //经过上面的操作数组i和j的下标的数都已经各自大于基准数和小于基准数 if(i&lt;j) &#123; //这个时候，就要交换这两个下标的数 int temp=arry[i];//交换两个数 arry[i]=arry[j]; arry[j]=temp; &#125; &#125; //实质是以6位基准数的最后一次交换数字，之后以这个基准数的左边和右边分别递归。 arry[left]=arry[i];//交换基准数1 arry[i]=p;//交换基准数2 quickSort(arry, left, i-1);//选择这个数组原来的基准数的左边进行递归。 quickSort(arry, i+1, right);//选择这个数组原来的基准数的右边进行递归。 &#125;&#125; C语言版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int a[10]=&#123;6,1,2,9,7,4,5,10,8&#125;;//1.首先全局变量定义一个数组int a[1000]=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;;//2.快排函数的三个实参是待快排的数组，//该数组的最左边的下标，该数组最右边的下标。void quickSort(int *arr,int left,int right)&#123; //3.定义i为左哨兵,j为右哨兵,p为基准兵(当前数组的基准兵为当前数组的左哨兵下标的值)看下图示 //6,1,2,9,7,4,5,10,8 //基准哨兵:p //左右哨兵:i j int i=left,j=right,p=arr[left]; //4.左下标大于等于右下标也就是快排排好的时候 if(left&gt;=right)&#123; return; &#125; while(i != j)&#123; while(arr[j]&gt;=p&amp;&amp;i&lt;j)&#123; j--; &#125; while(arr[i]&lt;=p&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; int temp ; temp =arr[i]; arr[i] =arr[j]; arr[j] =temp; &#125; &#125; arr[left] =arr[i]; arr[i] = p; quickSort(arr,left,i-1); quickSort(arr,i+1,right); &#125;int main()//1.写主函数&#123; int i; quickSort(a,0,999);//调用快排函数 for (i=0;i&lt;1000;i++)&#123; printf("%d\n",a[i]);//输出结果，codeblock先ctrl+F11编译，再ctrl+F10运行； &#125; return 0;&#125; 快速排序推荐阅读博客：http://developer.51cto.com/art/201403/430986.htm https://blog.csdn.net/liuyi1207164339/article/details/50827608 https://www.cnblogs.com/surgewong/p/3381438.html http://www.cnblogs.com/foreverking/articles/2234225.html https://www.cnblogs.com/y3w3l/p/6444837.html https://blog.csdn.net/liuzhenya1994/article/details/80254958]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之约瑟夫环问题求解策略《四》]]></title>
    <url>%2F2018%2F08%2F30%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.ArrayList;/** * 约瑟夫环 问题 * 获取幸运数字 * 思路： * ①集合数组的 * ②递归 */public class josephRing03 &#123; public static void main(String[] args)&#123; System.out.println("第一种方法：集合法"); System.out.println(getLuckNum01(10)); System.out.println("第二种方法：递归法"); System.out.println(getLuckNum02(10,3,8)); System.out.println(getLuckNum02(9,3,7)); System.out.println(getLuckNum02(8,3,6)); System.out.println(getLuckNum02(7,3,5)); System.out.println(getLuckNum02(6,3,4)); System.out.println(getLuckNum02(5,3,3)); System.out.println(getLuckNum02(4,3,2)); System.out.println("第三种方法：公式法");//本质也是递归 System.out.println(getlive(10, 3)); System.out.println(getlive( 9, 3)); System.out.println(getlive( 8 , 3)); System.out.println("第三.001种方法：公式形象记忆法");//本质也是递归 System.out.println(getLuckNum(10, 3)); System.out.println(getLuckNum(9, 3)); System.out.println(getLuckNum(8, 3)); &#125; //①数组集合法 public static int getLuckNum01(int num) &#123; //1.定义一个集合，并且添加人进去，10环就add十个人进去，100人环就add100个人进去 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= num; i++) &#123; list.add(i); &#125; //2.定义一个指针，区别于下面的i，这个count是直接跟人头对接的，所以要从1开始。 int count = 1; //3.遍历所有元素，一直“杀死”人直到只剩下最后一个人即list.size()!=1时都要继续遍历 /* System.out.println(list.size());*/ for (int i=0;list.size()!=1;i++)&#123; //4.如果已经遍历到最后一个人了，则重新开始，i重新等于0,又一个新环来进行“杀人”游戏 //注：这里要设置判断条件为list.size(),而不是list.size()-1是有原因的 //因为i作为下标一直遍历增加，直到最后一个下标，都是可以杀人的， //也就是说还可以进行下面的if判断以及count++ //所以，直到i增加到list.size时，已经可以说是下标越界了 //此时就要使得要越界的这个i变成0，重新开始新的“i生”（人生~哈哈哈） if(i==list.size())&#123; i =0; &#125; //5.当指针的对3求余为0时，去除掉list的这个元素。 //注：由于少了一个数，后面的数会补上前来，下标不变的话，i又必须得-1，才能不会错过当前的人 if(count%3 == 0)&#123; list.remove(i--); &#125; //6.count继续累加 count++; &#125; return list.get(0); &#125; //②递归法（大神法） public static int getLuckNum02(int sum,int value,int n) &#123; if( n ==1)&#123; return (sum+value-1)%sum; &#125; else&#123; return (getLuckNum02(sum-1, value, n-1)+value)%sum; &#125; &#125; //3.公式法 public static int getlive(int n,int m)&#123; if(n == 1)&#123;return 1;&#125; return (getlive(n-1,m)+m-1)%n+1;//背下来就可以了 &#125; //3.01形象记忆公式法 public static int getLuckNum(int sumMan,int jiange)&#123; if(sumMan == 1) &#123; return 1; &#125; else&#123; return (getLuckNum(sumMan-1,jiange)+jiange-1)%sumMan+1;//背下来就可以了 &#125; &#125;&#125; 总结： ①直接背公式。 ②理解指针指向。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之求长整数中所有0和尾数0的个数的策略《三》]]></title>
    <url>%2F2018%2F08%2F29%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%B1%82%E9%95%BF%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%80%E6%9C%890%E5%92%8C%E5%B0%BE%E6%95%B00%E7%9A%84%E4%B8%AA%E6%95%B0%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89%2F</url>
    <content type="text"><![CDATA[/** 求出：1000的阶乘所有零和尾部零的个数，不用阶乘。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.math.BigInteger;public class test1000For002 &#123; public static void main(String[] args)&#123; //错误方案： //demo01();1000阶乘远大于long的类型范围,行不通。 //正确方案： //calculateTheNumOfZeroTest01(); 求出这个大数字中所有0的个数 //calculateThelastZeroNum02(); 求出这个大数字中尾部0的个数 &#125; public static void calculateThelastZeroNum02() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; String string2 =b1.toString(); StringBuilder sb2 = new StringBuilder(string2); string2 =sb2.reverse().toString();//链式编程，反转字符串再赋值 int count2=0; for (int i = 0; i &lt;string2.length() ; i++) &#123; if('0'==string2.charAt(i))&#123; count2++; &#125; else &#123; break; &#125; &#125; System.out.println(count2);//249 &#125; public static void calculateTheNumOfZeroTest01() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; // System.out.println(b1); String string =b1.toString(); int count=0; /* char[] arr =string.toCharArray();*/ for (int i = 0; i &lt;string.length() ; i++) &#123; if('0' == string.charAt(i))&#123; count++; &#125; &#125; System.out.println(count); &#125; public static void demo01() &#123; long num =1; for(long i=1; i &lt;= 1000;i++)&#123; num =i * num; &#125; System.out.println(num); &#125;&#125; 总结：①当需求的数的个数超过int和long的类型的最大长度时，即2^32-1这个值时，可以利用java自带的类库BigInterger对数字进行字符串化并且利用类的方法进行求值。②考虑到求尾数0的个数，当看到求【尾数类】的题目时，要想到String中没有直接倒过来的方法，要把String放入StringBulidedr中，再利用StringBulider的方法对其进行反转，思路就开了。③链式编程了解一下emmm。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之斐波那契数列题型两种解题策略《二》]]></title>
    <url>%2F2018%2F08%2F28%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%A2%98%E5%9E%8B%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/**不死神兔 月月生问题 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 两种解题思路： ①利用数组 ②递归计算 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* *不死神兔 月月生问题 * 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 * 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 * 两种解题思路： * ①利用数组 * ②递归计算 */public class rabbitTest01 &#123; public static void main(String[] args)&#123; // ①利用数组(7行代码搞定) getRabbitNum01(); //②递归计算(2行代码搞定) //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.利用递归输出,核心是:fun(num) =fun(num-2)+fun(num-1); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+getNum(i+1)+"只"); &#125; &#125; public static int getNum(int i)&#123;//利用三元运算符使代码更简洁 return (i ==1||i ==2) ? 1 :(getNum(i-2)+getNum(i-1)); &#125;/*下面小测试的答案在这里：第10个月————21对大兔子生下21对小兔子————————13对小兔子长成13对大兔子 ——共55对（42+13）你做对了么?对了就请点个喜欢吧~~~*/ public static void getRabbitNum01() &#123; //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.初始化第一和第二个元素为1 arr[0]=arr[1]=1; //3.遍历一下这个数组，也就是让每个月都有个兔子总数值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i-2] +arr[i-1]; &#125; //4.选择输出每个月份的兔子总数，直观清晰 for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+arr[i]+"只"); &#125; &#125;&#125; 总结：规律掌握如下，一点点理解，这个不会太难。月份——————兔子生长情况——————兔子当月总对数第1个月————1对小兔子———————— 共1对第2个月————1对大兔子———————— 共1对第3个月————1对大兔子生下1对小兔子——共2对（1+1）第4个月————1对大兔子生下1对小兔子————————1对小兔子长成1对大兔子 ——共3对（1+2）第5个月————2对大兔子生下2对小兔子————————1对小兔子长成1对大兔子 ——共5对（2+3）第6个月————3对大兔子生下3对小兔子————————2对小兔子长成2对大兔子 ——共8对（6+2）第7个月————5对大兔子生下5对小兔子————————3对小兔子长成3对大兔子 ——共13对（10+3）第8个月————8对大兔子生下8对小兔子————————5对小兔子长成5对大兔子 ——共21对（16+5）第9个月————13对大兔子生下13对小兔子————————8对小兔子长成8对大兔子 ——共34对（26+8）小测试：看你懂了没？第10个月————？对大兔子生下？对小兔子————————？对小兔子长成？对大兔子 ——共？对（？+？）答案藏在本篇文章中，聪明人10秒钟内应该能看到。或者，自己把代码敲一遍，结果自然明白。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之二分查找题型的解题策略《一》]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A2%98%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 二分查找： 查找元素对应的索引 前提：数组有序，这点特别重要！！！要求的数组一定要按照顺序来的。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546package day13.searchAlgorithm;public class binarySearch &#123; public static void main(String[] args)&#123; int[] arr = &#123;11,22, 33, 44, 55&#125;; System.out.println(binarysearch(arr,11)); System.out.println(binarysearch(arr,22)); System.out.println(binarysearch(arr,33)); System.out.println(binarysearch(arr,44)); System.out.println(binarysearch(arr,55)); System.out.println(binarysearch(arr,66)); System.out.println(binarysearch(arr,77)); &#125; private static boolean binarysearch(int[] arr, int num) &#123; /** * 二分查找3点 * 1.确定 小中大 3个索引 * 2.判断 中索引 的值是否等于 待查值，等于即返回true，不等于进入while循环 * 3.判断 值的索引与中的索引的大小， 中大就大索引改为中大索引-1， 中小就小索引改为中大索引+1， 中大索引本身改为大小索引之和的一半 * 4.当小索引大于大索引时返回false */ int max = arr.length - 1; int min = 0; int mid = (max + min) / 2; Boolean flag; while (arr[mid]!=num) &#123; //当中间值 mid = (max + min) / 2; if (arr[mid] &gt; num) &#123; max = mid - 1; &#125; else if (arr[mid] &lt; num) &#123; min = mid + 1; &#125; if(min&gt;max)&#123; return false; &#125; &#125; return true; &#125;&#125; 总结：二分查找关键在于数组中数字要有序，其次是确定好三个索引的大小关系。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16分钟教你搭建一个Hexo博客>]]></title>
    <url>%2F2018%2F08%2F10%2FHexo%E6%90%AD%E5%BB%BAnext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8F%82%E8%80%83001%2F</url>
    <content type="text"><![CDATA[目的：搭建一个hexo.next主题的博客 用时：大约要16分钟左右 条件：①一个git-bash命令行窗口②一个npm打包工具③一个node.js运行环境④一个gitHub账号]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铭戈栈]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%93%AD%E6%88%88%E6%A0%88%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法：①标题大小 铭戈栈的第一篇博客markDown语法###②大小列表 java a IDE的选择 b 数据类型 c 数组 d 类文件 .class和.java的区别 e String类的使用 c++ 算法 ③引用外链第一种java博客学习对象第二种（优先）java博客学习对象 ##改字体④斜体字/这个字好像是斜体的！！/⑤删除字这是加删除线的文字⑥加粗这是加粗的文字⑦斜体加粗这是斜体加粗的文字 ##插入东西 三个横线： ##引用图片： ##代码区：1234567&lt;html&gt; &lt;title&gt; 我是标题 &lt;/title&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; ##引用区 第一个引用 第二个引用]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>目录</tag>
        <tag>个人简介</tag>
      </tags>
  </entry>
</search>
