<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java面试题之约瑟夫环问题求解策略《四》]]></title>
    <url>%2F2018%2F08%2F30%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.ArrayList;/** * 约瑟夫环 问题 * 获取幸运数字 * 思路： * ①集合数组的 * ②递归 */public class josephRing03 &#123; public static void main(String[] args)&#123; System.out.println("第一种方法：集合法"); System.out.println(getLuckNum01(10)); System.out.println("第二种方法：递归法"); System.out.println(getLuckNum02(10,3,8)); System.out.println(getLuckNum02(9,3,7)); System.out.println(getLuckNum02(8,3,6)); System.out.println(getLuckNum02(7,3,5)); System.out.println(getLuckNum02(6,3,4)); System.out.println(getLuckNum02(5,3,3)); System.out.println(getLuckNum02(4,3,2)); System.out.println("第三种方法：公式法");//本质也是递归 System.out.println(getlive(10, 3)); System.out.println(getlive( 9, 3)); System.out.println(getlive( 8 , 3)); System.out.println("第三.001种方法：公式形象记忆法");//本质也是递归 System.out.println(getLuckNum(10, 3)); System.out.println(getLuckNum(9, 3)); System.out.println(getLuckNum(8, 3)); &#125; //①数组集合法 public static int getLuckNum01(int num) &#123; //1.定义一个集合，并且添加人进去，10环就add十个人进去，100人环就add100个人进去 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= num; i++) &#123; list.add(i); &#125; //2.定义一个指针，区别于下面的i，这个count是直接跟人头对接的，所以要从1开始。 int count = 1; //3.遍历所有元素，一直“杀死”人直到只剩下最后一个人即list.size()!=1时都要继续遍历 /* System.out.println(list.size());*/ for (int i=0;list.size()!=1;i++)&#123; //4.如果已经遍历到最后一个人了，则重新开始，i重新等于0,又一个新环来进行“杀人”游戏 //注：这里要设置判断条件为list.size(),而不是list.size()-1是有原因的 //因为i作为下标一直遍历增加，直到最后一个下标，都是可以杀人的， //也就是说还可以进行下面的if判断以及count++ //所以，直到i增加到list.size时，已经可以说是下标越界了 //此时就要使得要越界的这个i变成0，重新开始新的“i生”（人生~哈哈哈） if(i==list.size())&#123; i =0; &#125; //5.当指针的对3求余为0时，去除掉list的这个元素。 //注：由于少了一个数，后面的数会补上前来，下标不变的话，i又必须得-1，才能不会错过当前的人 if(count%3 == 0)&#123; list.remove(i--); &#125; //6.count继续累加 count++; &#125; return list.get(0); &#125; //②递归法（大神法） public static int getLuckNum02(int sum,int value,int n) &#123; if( n ==1)&#123; return (sum+value-1)%sum; &#125; else&#123; return (getLuckNum02(sum-1, value, n-1)+value)%sum; &#125; &#125; //3.公式法 public static int getlive(int n,int m)&#123; if(n == 1)&#123;return 1;&#125; return (getlive(n-1,m)+m-1)%n+1;//背下来就可以了 &#125; //3.01形象记忆公式法 public static int getLuckNum(int sumMan,int jiange)&#123; if(sumMan == 1) &#123; return 1; &#125; else&#123; return (getLuckNum(sumMan-1,jiange)+jiange-1)%sumMan+1;//背下来就可以了 &#125; &#125;&#125; 总结： ①直接背公式。 ②理解指针指向。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之求长整数中所有0和尾数0的个数的策略《三》]]></title>
    <url>%2F2018%2F08%2F29%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%B1%82%E9%95%BF%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%80%E6%9C%890%E5%92%8C%E5%B0%BE%E6%95%B00%E7%9A%84%E4%B8%AA%E6%95%B0%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89%2F</url>
    <content type="text"><![CDATA[/** 求出：1000的阶乘所有零和尾部零的个数，不用阶乘。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.math.BigInteger;public class test1000For002 &#123; public static void main(String[] args)&#123; //错误方案： //demo01();1000阶乘远大于long的类型范围,行不通。 //正确方案： //calculateTheNumOfZeroTest01(); 求出这个大数字中所有0的个数 //calculateThelastZeroNum02(); 求出这个大数字中尾部0的个数 &#125; public static void calculateThelastZeroNum02() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; String string2 =b1.toString(); StringBuilder sb2 = new StringBuilder(string2); string2 =sb2.reverse().toString();//链式编程，反转字符串再赋值 int count2=0; for (int i = 0; i &lt;string2.length() ; i++) &#123; if('0'==string2.charAt(i))&#123; count2++; &#125; else &#123; break; &#125; &#125; System.out.println(count2);//249 &#125; public static void calculateTheNumOfZeroTest01() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; // System.out.println(b1); String string =b1.toString(); int count=0; /* char[] arr =string.toCharArray();*/ for (int i = 0; i &lt;string.length() ; i++) &#123; if('0' == string.charAt(i))&#123; count++; &#125; &#125; System.out.println(count); &#125; public static void demo01() &#123; long num =1; for(long i=1; i &lt;= 1000;i++)&#123; num =i * num; &#125; System.out.println(num); &#125;&#125; 总结：①当需求的数的个数超过int和long的类型的最大长度时，即2^32-1这个值时，可以利用java自带的类库BigInterger对数字进行字符串化并且利用类的方法进行求值。②考虑到求尾数0的个数，当看到求【尾数类】的题目时，要想到String中没有直接倒过来的方法，要把String放入StringBulidedr中，再利用StringBulider的方法对其进行反转，思路就开了。③链式编程了解一下emmm。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之斐波那契数列题型两种解题策略《二》]]></title>
    <url>%2F2018%2F08%2F28%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%A2%98%E5%9E%8B%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/**不死神兔 月月生问题 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 两种解题思路： ①利用数组 ②递归计算 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* *不死神兔 月月生问题 * 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 * 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 * 两种解题思路： * ①利用数组 * ②递归计算 */public class rabbitTest01 &#123; public static void main(String[] args)&#123; // ①利用数组(7行代码搞定) getRabbitNum01(); //②递归计算(2行代码搞定) //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.利用递归输出,核心是:fun(num) =fun(num-2)+fun(num-1); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+getNum(i+1)+"只"); &#125; &#125; public static int getNum(int i)&#123;//利用三元运算符使代码更简洁 return (i ==1||i ==2) ? 1 :(getNum(i-2)+getNum(i-1)); &#125;/*下面小测试的答案在这里：第10个月————21对大兔子生下21对小兔子————————13对小兔子长成13对大兔子 ——共55对（42+13）你做对了么?对了就请点个喜欢吧~~~*/ public static void getRabbitNum01() &#123; //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.初始化第一和第二个元素为1 arr[0]=arr[1]=1; //3.遍历一下这个数组，也就是让每个月都有个兔子总数值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i-2] +arr[i-1]; &#125; //4.选择输出每个月份的兔子总数，直观清晰 for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+arr[i]+"只"); &#125; &#125;&#125; 总结：规律掌握如下，一点点理解，这个不会太难。月份——————兔子生长情况——————兔子当月总对数第1个月————1对小兔子———————— 共1对第2个月————1对大兔子———————— 共1对第3个月————1对大兔子生下1对小兔子——共2对（1+1）第4个月————1对大兔子生下1对小兔子————————1对小兔子长成1对大兔子 ——共3对（1+2）第5个月————2对大兔子生下2对小兔子————————1对小兔子长成1对大兔子 ——共5对（2+3）第6个月————3对大兔子生下3对小兔子————————2对小兔子长成2对大兔子 ——共8对（6+2）第7个月————5对大兔子生下5对小兔子————————3对小兔子长成3对大兔子 ——共13对（10+3）第8个月————8对大兔子生下8对小兔子————————5对小兔子长成5对大兔子 ——共21对（16+5）第9个月————13对大兔子生下13对小兔子————————8对小兔子长成8对大兔子 ——共34对（26+8）小测试：看你懂了没？第10个月————？对大兔子生下？对小兔子————————？对小兔子长成？对大兔子 ——共？对（？+？）答案藏在本篇文章中，聪明人10秒钟内应该能看到。或者，自己把代码敲一遍，结果自然明白。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之二分查找题型的解题策略《一》]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A2%98%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 二分查找： 查找元素对应的索引 前提：数组有序，这点特别重要！！！要求的数组一定要按照顺序来的。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546package day13.searchAlgorithm;public class binarySearch &#123; public static void main(String[] args)&#123; int[] arr = &#123;11,22, 33, 44, 55&#125;; System.out.println(binarysearch(arr,11)); System.out.println(binarysearch(arr,22)); System.out.println(binarysearch(arr,33)); System.out.println(binarysearch(arr,44)); System.out.println(binarysearch(arr,55)); System.out.println(binarysearch(arr,66)); System.out.println(binarysearch(arr,77)); &#125; private static boolean binarysearch(int[] arr, int num) &#123; /** * 二分查找3点 * 1.确定 小中大 3个索引 * 2.判断 中索引 的值是否等于 待查值，等于即返回true，不等于进入while循环 * 3.判断 值的索引与中的索引的大小， 中大就大索引改为中大索引-1， 中小就小索引改为中大索引+1， 中大索引本身改为大小索引之和的一半 * 4.当小索引大于大索引时返回false */ int max = arr.length - 1; int min = 0; int mid = (max + min) / 2; Boolean flag; while (arr[mid]!=num) &#123; //当中间值 mid = (max + min) / 2; if (arr[mid] &gt; num) &#123; max = mid - 1; &#125; else if (arr[mid] &lt; num) &#123; min = mid + 1; &#125; if(min&gt;max)&#123; return false; &#125; &#125; return true; &#125;&#125; 总结：二分查找关键在于数组中数字要有序，其次是确定好三个索引的大小关系。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16分钟教你搭建一个Hexo博客>]]></title>
    <url>%2F2018%2F08%2F10%2FHexo%E6%90%AD%E5%BB%BAnext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8F%82%E8%80%83001%2F</url>
    <content type="text"><![CDATA[目的：搭建一个hexo.next主题的博客 用时：大约要16分钟左右 条件：①一个git-bash命令行窗口②一个npm打包工具③一个node.js运行环境④一个gitHub账号]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铭戈栈]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%93%AD%E6%88%88%E6%A0%88%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法：①标题大小 铭戈栈的第一篇博客markDown语法###②大小列表 java a IDE的选择 b 数据类型 c 数组 d 类文件 .class和.java的区别 e String类的使用 c++ 算法 ③引用外链第一种java博客学习对象第二种（优先）java博客学习对象 ##改字体④斜体字/这个字好像是斜体的！！/⑤删除字这是加删除线的文字⑥加粗这是加粗的文字⑦斜体加粗这是斜体加粗的文字 ##插入东西 三个横线： ##引用图片： ##代码区：1234567&lt;html&gt; &lt;title&gt; 我是标题 &lt;/title&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; ##引用区 第一个引用 第二个引用]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>目录</tag>
        <tag>个人简介</tag>
      </tags>
  </entry>
</search>
