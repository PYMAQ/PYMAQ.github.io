<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[架构师之路史诗级必读书单吐血整理四个维度系列80+本书(珍藏版)]]></title>
    <url>%2F2018%2F10%2F24%2FToCoder%2F</url>
    <content type="text"><![CDATA[互联网行业的特点是变化。若要提高互联网开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。 以下就给想要成为架构师的程序猿们推荐从事技术生涯这一辈子都要花时间去看的书单，以及一份技术书阅读方法论总结： 前言：技术书阅读方法论一.速读一遍（最好在1~2天内完成）人的大脑记忆力有限，在一天内快速看完一本书会在大脑里留下深刻印象，对于之后复习以及总结都会有特别好的作用。 对于每一章的知识，先阅读标题，弄懂大概讲的是什么主题，再去快速看一遍，不懂也没有关系，但是一定要在不懂的地方做个记号，什么记号无所谓，但是要让自己后面再看的时候有个提醒的作用，看看第二次看有没有懂了些。 二.精读一遍（在2周内看完）有了前面速读的感觉，第二次看会有慢慢深刻了思想和意识的作用，具体为什么不要问我，去问30年后的神经大脑专家，现在人类可能还没有总结出为什么大脑对记忆的完全方法论，但是，就像我们专业程序员，打代码都是先实践，然后就渐渐懂了过程，慢慢懂了原理，所以第二遍读的时候稍微慢下来，2周内搞定。记住一句话：没看完一个章节后，总结一下这个章节讲了啥。很关键。 三.实践（在整个过程中都要）实践的时候，要注意不用都去实践，最好看着书，敲下代码，把重点的内容敲一遍有个肌肉记忆就很不错了。这个过程最好结合”费曼思想”进行思考，反思，总结。当然如果能把刚刚学习到的内容结合现在做的项目‘注入’，即即学即用，效果甚佳。 以及到自己做过的项目中去把每个有涉及的原理的代码，研究一遍，就可以了 网盘下载链接架构师之路史诗级必读书单吐血整理四个维度系列80+本书链接：https://pan.baidu.com/s/1H1et7CxdjyATyERQDBGvnQ提取码：1kez备注：文件比较大，网盘直接打开会显示损坏，里面已经整理并且压缩好，需要下载后才可以打。 资源图示： 想要成为架构师的程序员一生必读的书，分为以下四个部分：1.Coding Practice(编程实践系列)2.Architecture Design(架构与设计系列)3.Methodology(方法学系列)4.Thought Leadership(思想与领导力系列)5.奇门遁甲系列6.互联网大佬奇迹传记系列： 架构师一生必读书籍推荐理由：一.编程实践系列：1 《代码整洁之道》 《代码整洁之道》讲述了一系列行之有效的整洁代码操作实践。软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。 这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。《代码整洁之道》提出一种观念：代码质量与其整洁度成正比。 干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，这些实践在《代码整洁之道》中体现为一条条规则(或称“启示”)，并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。 2 《卓有成效的程序员》 垂涎这本书很久，终于花了一天时间看完了。本书所介绍的最主要的不是工具和方法，而是思想，有助于我们提升工作效率的思想。 工具和方法是其次的，只要理解掌握这些思想，并在实际工作中运用到，就能够大大提升我们的工作效率了。 总的来说，这本书还是很优秀的，是一本「集大成」的书籍。里面很多想法和概念通过阅读其他书籍也能接触到，只不过在这本书里面，作者结合自己的亲身经验总结来介绍，更有助于理解这些想法。在我看来，整本书一直都在灌输着三个思想： 一、经典的还是好的 二、尽量把事情交给计算机来完成作者有句话我是很赞同的：只要做过一次的事情，以后很大程度要重复做。 三、选择最合适的，而不是追求最好的。 3 《程序员的职业素养》 Robert C.Martin的大名咱就不说啥了。这本书写的深入浅出，感觉像读一本小说，流畅自然，但自然而然的就学到了很多东西。结合工作经验，常有种“确实如此”的感觉。 该书尤其适合初入职场，试图成为“专业人员”的人。其中永远不要说“我试试”和有关测试的章节给我留下了深刻印象。 4 《重构与模式》 只是看了一半，因为其中每个例子都含有作者实践过的真实代码，非常适合我们跟着作者的思路去思考，运用设计模式进行重构，解决眼前存在的难题！ 5 《代码大全》 初见《代码大全》，还是该书的第一版，只从书名上看，还以为都是一些代码的示例。觉得还有很多的书需要读，这种实用主义的技巧书，可以先放一放，于是与之失之交臂。 及至后来，才发现原来被中文书名给骗了。只要将目录浏览一过，就会发现，这本书基本覆盖了软件构建的全过程，从需要分析、系统架构设计到具体的编码规范、编码技巧，程序员可以在其中找到所有想找到的内容。 而且每一个方面作者都进行了深入的探讨和详细的解说，同时也给出了想要更进一步学习的参考。可以说，这是一本对其出版之前的所有软件构建的知识的百科全书。 对于争论较多的方面，作者给出了较为合理、公允的折中方案，甚至在34章最后一节”汝当分离软件与信仰“，作者明确的阐述了这一思想。 这本书和《程序员修炼之道》一厚一薄，相映成趣，都是难得一见的好书，值得花时间和精心用心的阅读，并不时拿出来温习，可以肯定的是，每次翻开，必有收获！ 6 《实现模式》 这是一本关注程序细节并具有浓厚实战意义的书籍, 它主要是来告诉我们如何写出容易让人理解的代码. 如果非要在书名前加一个限定词的话, “java实现模式”可能更贴切一些, 因为里面的代码都是以java作为例子来说明的. 作者是junit的贡献者之一, 因此里面的很多例子都是从junit中来的. 这本书也解决了很多自己在实际开发中的一些抉择困惑. 是一本非常值得常看的书籍. 另外翻译的也非常不错, 不像有些书让人看了云里雾里的, 不知所云.本书按照方法, 行为, 类, 状态, 集合, 框架的顺序依次对相关的实现模式加以说明来阐述如何写出好的代码. 也是本书的重点, 集合主要是在讲java.util下的集合类的使用法则, 框架部分主要是框架的开发有自己的规则, 围绕兼容性, 扩展性方面在说事儿。 7 《程序员修炼之道》 很久以前买的这本书，忘记在哪里看到这部书的推荐了，有大牛很卖力的推荐，于是去买了一本。 坦白讲，那个时候自己是完完全全的菜鸟，从大学里出来，除了会编程啥也不懂，这本书在当时真的是指路明灯。 书中的道理很浅显，可是对于菜鸟却是至理名言。基本为你勾勒了一个成熟软件程序员专家所需要的所有特性。 我自觉地获益颇多，其中很多事情，要么在当时是自己没有想到的，要么是发生了，自己没有注意的等等。给我影响很大。当然，有些自以为是的”大牛”是鄙视这些的，因为看起来不够高深，随便吧，反正它讲的是从小工到专家，我是从小工过来的，那些凭空冒出来的“专家”不看也罢。 8 《高性能MySQL》 书很厚，内容非常全面，基本涵盖了所有使用中需要了解的基础和进阶知识，认真看完基本就没有知识死角了 书的语言风格和内容编写都非常好，没有废话，全书无任何尿点，每一节每一段话都很重要,作者们是mysql DBA届的大牛，经验和知识水平没得说，尤其让人如沐春风的是作者的一些谆谆教诲，大师风范跃然纸上国内tb大牛翻译的也很棒。 非常好的一本书，五星力荐，即使你不是DBA也值得一读。稍微美中不足的就是知识的深度上有所欠缺，很多知识点讲出来了，但是背后的原理却没有触及，当然这和本书偏向应用的定位有关 9 《修改代码的艺术》 这本书很薄，但是看起来还是很吃力，里面介绍了很多重构的知识，而且有很多c++的内容，有的地方也是似懂非懂的，如果了解设计模式和重构，就会轻松很多，可能艺术这东西，本身就不容易懂吧。 里面对单元测试的依赖性很强，其实还是一本不错的书，你完全可以领略到作者真的把代码的修改看成是一种艺术，软件工程师要做到匠人的地步也着实不容易。看得出写代码不是一件简单的事情，是需要经验的，不像国内这样，写代码是年轻人的事情，其实没有时间的锤炼是写不出好的代码来的，即使写出来也不能谈得上是艺术了。 希望将来再次翻起这本书时会有更多的领悟。 10 《计算机程序的构造和解释》 这是一本很有趣的书，任何对编程真正感兴趣的人都应该看看。它讲了程序结构的很多方面，但始终围绕着一个主题，那就是从各个层次上来减少计算的复杂度。 这和我读过的另外几本书核心是一样的，只是维度不同。比如《代码大全》厚厚的一本书讲的也是管理复杂，但是它针对的是软件工程这门工作该从哪些方面来提高生产效率，减少沟通和维护的成本，比如变量名该怎样起，函数该多长，注释该怎么写。 而这本书的出发点是各种编程问题，重点放在该如何分层以减少程序的复杂度，有点像是《Head First设计模式》，讨论的也是如何封装变化，针对接口编程等等，不过《SICP》里的问题难得多而已，类似算法一样很费脑筋。 11 《重构：改善既有代码的设计(中文版)》 Martin Fowler 的《重构-改善既有代码的设计》这本书，是我大学老师推荐给我的。 当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000+行）， 就会逐渐失去对代码的控制能力。 这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书， 将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。 12 《调试九法——软硬件错误的排查之道》 一般当工程师把一个东西称为艺术甚至玄学的时候，说明这个东西难度很大，没有太多规律可以遵循，调试就属于此列。几乎每个程序员都有被bug搞到死去活来的经验，有时候颠来倒去，问题似乎解决了，但也不知道为什么，就把它当作不可解释的玄学现象，最烦人的一种bug是偶尔出现难以复现的，学名海森堡bug。 不过毕竟软件还是属于科学技术的范畴，调试也应当是门技术活。《调试九法》是一本少见的讲调试技术的书，九个普遍性的原则不仅适用于软硬件开发维护，甚至还能运用到日常生活，为了找到这本书我也是费了点神，幸好图灵社区还有正版的电子书卖。 说实话，作者举的很多例子偏硬件，所以理解起来有点隔膜，但是九个原则确实很实用，在我以前的开发调试经历中可能也不自觉的总结过一些，但是看了本书，还是有拿到武功心法的感觉。 13 《算法设计与分析基础第3版》 对算法做了一个很新颖的划分，可以看到它和我们经常看的算法书的知识点划分很不一样。作者得归类很不错。对一些常用思想做了分类。 比如作者对分治做了几个分类。纯思维层面的切入分析，而不像以前的分为一般算法和图论那样子。 书中有不错的习题。思想描述有一定的思维引导性质。 14 《实用J2EE设计模式编程指南》 从应用的层次看来。从价格和其本身的内容这个角度来比较的话，这本书还是很划算的。其前1/3的对设计模式的总结还是十分清晰的。而后面的相当多的关于EJB的内容就是根据读者的需要来看了。 15 《编写可读代码的艺术》 姑且不谈该书中提到的程序最优与否，本书在给广大的程序员上了一堂关键的编程品德学。就如同科学发展到一定程度出现对科学家应该具有什么品德展开讨论一样，本书也提出了作为一个出色的、有责任心的程序员应该具有的品质——让他人更容易看懂自己的代码。 从个人经验来谈，身边很多人编程时都是考虑如何完成程序的使命，很少有人去考虑别人是否看得懂。结果造成当别人看你程序时看不懂，问你你又不耐烦讲这种局面数不胜数。 本书从根本上——即编程的基本思想层面，告诉广大编程的人要具有编程的责任感，方便大家的同时才能方便自己。所以该书对程序员在思想启蒙上是一本不可多得的好书。 16 《大话设计模式(带目录完整版)》 用了三天时间把书看完了，确实是设计模式的入门书。虽然书中有些例子举得并不十分恰当，但基本上也把每个设计模式讲清楚了。 国内很多教材和教师讲述专业知识都是很枯燥的，如此则把很多初学者拒之门外，让一部分人丧失了学习的兴趣。而这本书则类似于少数名师一样，采用交互式及启发式地讲述方式，在不知不觉中向读者传授了知识。 就我个人而言，更倾向于如同专业论文一般严谨的表述方式，但如此以来在理解上就要多花一些工夫了。我们需要类似Gof《设计模式》的经典，但就目前而言，像本书一样，以大家所熟知的例子来描述问题，步步深入，具有中国特色风格的书，才是我们更加需要的。难得见到国人出的精品书籍，给5 分。 17 《程序设计方法》 这本书写得很nice，如果有人讲的话，小朋友是看得懂的。但是需要有小学数学的基础，否则的话开始的练习会不知所云。我想过，把开始的练习给改成字符串处理的话，会不会简单一点——最后觉得不会。 原因是为了说明白“嵌套”是怎么回事，小朋友一定先得有小学的算术表达式可以嵌套的这个观念才行。所以本书不推荐给国内五年级以下代数感觉不很好的小朋友。 18 《七周七语言：理解多种编程范型》 众所周知，每一种语言或复杂或简单，使用者想要使用到一定境界，都不是短短一周可以达成的。所以这本书从根本上就不是像副标题中描述的A Pragmatic Guide to Learning Programming Languages。 这本书更像是对“非主流”的语言界的一次全面概括。作者精挑细选的7门语言基本囊括了“非主流”界的各种范式，也不乏“非主流”界中的主流，名门望族。细致的描述了每一个语言的特性，以及多种语言之间的对比。 对于每一个喜欢language，想要了解language的计算机爱好者都不应该错过。有志想去独立的设计一个language的爱好者当然更不应该错过。 19 《程序设计语言——实践之路》 一句话，对于那些有兴趣了解程序设计语言的基本设计与功能的软件工程师而言，这是一本入门的好书。特别有助于深入了解某一种程序语言的特点，理解其优势与软肋，进而用好它，而不是迷失于世面上众多的语言的花哨的特性中。 20 《程序设计实践》 这是一本牢牢占据经典书架最起眼位置的小册子，也是最符合KISS之道的神作之一。 抛开已有的业界的best practices，这本书还修正了我记忆中的很多错误认识，Brian Kernighan、Rob Pike的大名自然是本书最好的招牌；但作者的求实态度更值得每一个认真的programmer学习。 整体上，全书采用一个实际问题作为切入点并且贯穿全书，涵盖了programming工作的各个方面，简明扼要却又发人深省。这个例子的选取本身就是非同谨慎的，规模不至于过大（100多行代码）但是又足以说明问题。 我最欣赏的是作者并没有特意偏袒C语言这个Unix的宠儿，而是兼顾了Java、C++、awk三种语言，并用事实揭示了如何更好的使用语言，如何在实际问题和应用场景中取舍。 读完全书，我特意从本书的网站上自习运行了作者的源程序，书中对于很多地方的分析和数据比较，在数年后技术突飞猛进的今天仍然没有发生本质变化。 21 《编码：隐匿在计算机软硬件背后的语言（美）佩措尔德》 当年参加计算机大赛的时候有个同学和我说计算机方面的东西，千万不要想太多……到今天我才明白他的意思。 1.这本书讲的是关于计算机工作原理最本质的问题，即使跨了一层语言仍然能感觉到原著深入浅出的风格，很详细； 2.想读得深入一点不妨准备点演算纸，我用掉了一叠A4画逻辑门； 3.如果当做一本教材来看，逻辑门部分的阐述是重点，是难点，也最有趣； 4.读完之后会明白为什么电气工程师那么值钱，因为不是变态搞不来； 5.个人觉得翻译还不错，或许和无对比有关，但技术部分并不存在太大问题，至少我一个外行看懂无碍； 6.打算以后会没事就拿出来翻翻。力荐。 22 《编程原本》 本书提供了有关编程的一种与众不同的理解。其主旨是，实际的编程也应像其他科学和工程领域一样基于坚实的数学基础。本书展示了在实际编程语言（如C++）中实现的算法如何在最一般的数学背景中操作。 这不是一本很容易读的书，它也不是能提升你的编程技能的秘诀和技巧汇编。本书的价值是更根本性的，其终极目标是提升你对编程的洞察力。要想从中大获裨益，需要从头到尾认真学习：阅读代码，证明引理，完成练习。到结束之时，你将看到如何把这里讨论的演绎方法应用到你的程序中，保证你做出的软件部件能一起工作，并表现出它们所应该表现的行为。 二.架构与设计系列：1 《敏捷软件开发：原则、实践与模式》 好的技术书籍的标准是通俗易懂；文字精炼；耐读，有吸引力；有思想性。uncle bob的书写功力有目共睹，而且他的技术修为也绝对无人质疑。因此他写的这本书秉承了他一贯的优势。符合所有好处所具备的条件。所有我们可以毫无内疚的宣称，“这本书是我见过最好的书”。孟岩作序，也为这本书的推广添砖加瓦。在序中他表现出来的轻身意切，让我们感受到了一个技术人员丰富的人文情怀。这也是我们搞技术的梦寐以求的一个高级阶段。 2 《深入浅出设计模式》 这是我看过最幽默最搞笑最亲切同时又让我收获巨大的技术书籍！森森的膜拜Freeman(s)！Amen！深入浅出，娓娓道来，有的地方能笑死你！不知是翻译还是原著的问题，有几个小地方有点小错误，个人观点，值得商榷。但是瑕不掩瑜啦！其实我最先买的那本是四人帮写的，四人帮那本是这本书的五分之一厚。但是这本书我只花了三天时间就读完了！ 3 《Unix编程艺术》 作为一个多年的开源（Open Source）拥趸，像《UNIX编程艺术》（The Art of Unix Programming）这样的好书自然不能错过。大约一周前我无意中在公司书柜中发现了它，立刻开始投入阅读。现在，我已经开始边读第二遍边作读书笔记了。开篇的译序很有趣，第一句话就写道：“大多数译序是给作者说好话，顺便带动以下译本销量的，本篇是一个例外。”这是我见过的最棒的序言开头之一，在表明了自己独特的观点和立场的同时，译者还有效地激起了读者的好奇心。我记得看到这儿当场就笑了。 4 《企业应用架构模式》 这本书真是相见恨晚！做企业应用这么多年，第一次看到一本书里把这些数据库对象关系、事务、并发、领域模型、MVC等等讲得这么详细而深入。Martin真不愧是大师级人物，读他的书你会很佩服他的观察力，那种善于从司空见惯的日常现象中发现秩序的能力。 5 《领域驱动设计.软件核心复杂性应对之道.软件核心复杂性应对之道》&gt;全篇最核心的概念是，人类的记忆力思考力限制，会将一个大型系统耦合复杂化。为了更好的理解及团队成员的合作，必须将核心领域剥离出来。文章用很多篇幅讲述了剥离的方法，一句话，没有最正确的，只有更合适的，实践是检验方法的唯一办法。我个人最深的感触是：做减法。在系统中先做减法，抽离出核心的领域，并不断重构，最终得到各个核心领域的关联及通用模型、模块。由于文章过于久远，以及翻译的问题，很多地方显得臃肿及啰嗦，甚至话痨。适合快速阅读。 6 《企业集成模式：设计、构建及部署消息传递解决方案》&gt;这是一本有关使用消息传递进行企业集成的书。这本书并不只是介绍某种特别的技术或产品，而是为使用各种消息传递产品和技术的开发人员以及集成人员准备的。本书不会为企业应用集成建立商业案例，而是把重点放在如何实现应用的集成上。通过本书可以学会如何集成企业应用。. 7 《架构之美》&gt; 这是我读过的书中没读完就匆匆束之高阁的为数不多的书之一。连陈莱的《有无止境》我都坚持着看完了。而这本，实在读不下去了。理由一：架构之美很难一句两句说清。美，本身是很虚幻的。不同人的认同度是不一样的。就像是建筑物，哥特式尖顶和拜占庭式圆穹顶各有偏好一般。理由二：架构之美，很难讲清。即使这是一本案例教学的书，但这些案例都很大。短短十几页或者二十几页的文字如何能淋漓尽致的描述清楚呢？浮光掠影的提纲挈领，必然导致走马观花的感悟。只是隐隐约约的感受一下如此架构的味道，无法有切肤之感。理由三：关于对架构理解的悟性。鄙人很少做架构方面的东西，对架构之美的领悟力自然不行。不过这本书作为“之美”系列，还是有可圈可点的地方的，不过较之代码之美可就不止是小巫见大巫了。 8 《面向模式的软件架构_卷5_模式与模式语言》&gt;纸质书借于美团图书馆，只半小时浏览，论文式语调，不偏向应用。适合写作时作为参考语料。 9 《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》&gt;总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，看后能快速运用到实践项目中。不管是软件开发人员，还是运维人员，通过阅读《亿级流量网站架构核心技术》都能系统地学习实现亿级流量网站的架构核心技术，并收获解决系统问题的思路和方法。 10 《领域特定语言》&gt;挺厚的一本书，如作者所说，要写的太多了，但是为了能出版，不可能面面俱到。是个很有难度的主题，作者也算是费劲心思。虽然是DSL，但本质还是归到编译那套东西（主要是前端），尤其是对于外部DSL，因此我会觉得《编程语言实现模式》更精彩一些。另外吐槽两点，一是有些示例代码喧宾夺主了，代码的逻辑比传达的模式要复杂；二是翻译有改进的空间。 11 《元素模式》 主要介绍了一种思想，一种工具。 思想是，将大众熟知的设计模式分解为更细粒度的元素模式。使用元素模式去自由组合发散，扩张现有设计模式，同时令他们的经过度大大上升。 工具是使用PIN 箱，使用PIN箱来分析设计模式，将模式之间的组合关系表达得更加清楚。可以让人们对于模式的日常交流更容易，更方便。 12 《设计模式：可复用面向对象软件的基础》 我感觉看这本书，有几个层次，每个层次对应着软件开发方面的境界。第一个层次，看不懂。所谓模式，就是在长期写代码的过程中总结出来的一种经验。这在刚毕业或者工作一两年的软件开发的工程师中，很多就反应这本书很深奥，难看懂。一方面，书中的例子是C++写的，而且时间比较早，例子有点过时，另一个方面，自己经验不足，没有切身体会，对于其中的模式，无法联系到实际情况去理解。第二个层次，往上靠。不管实际需要不需要，非得用上几个模式，觉得这样代码才漂亮，才上了档次。其实，用模式，是一种好的现象，但是希望在用的时候，问自己两个问题，用有什么好处？不用会有什么问题？如果回答上来了，则用;回答不上来，则不要用。大部分人，处于这个层次，我见过很多。最大的问题就是，把简单的问题复杂化，复杂问题简单化。第三个层次，已忘记。会游泳的人，在游泳的时候，可能没人会想起游泳的注意事项以及要领。手脚和换气的动作，已经变成了肌肉的条件反射了。什么时候能够把模式变成你的手指的条件反射，那离编程高手就不远了。要达到这个层次，没有别的办法，不写几十万的代码是很难达到的。如果有志于编程，这本书应当是一本床头读物，学而时习之，时不时的拿出来看看，会有新的收获，编程是一种实践的工作，只有不断的coding，才能够提高，当已经达到忘了什么是模式，什么是架构的时候，已经可不看这本书了。 13 《设计模式：Java语言中的应用》 记得当时读的感觉是“略懂”，为了加深对设计模式的理解还照本宣科的模仿command pattern和Factory pattern写了一个基于数据库和Swing的ATM程序。现在回想起来，当时对设计模式既感到神秘又好奇的感觉真的很有意思。同时，真是《设计模式：Java语言中的应用》这本书帮我开启了设计模式的大门，浅显易懂，理论与实例结合，而且实例都写得很到位，这是这本书优秀的原因之一。 14 《编程珠玑（第2版）（第一部）》&gt;打开这颗薄薄的珍珠，认真拜读了前言，记得非常清楚是作者说，一次不要读太多，一章足矣。 再读完第一篇，认真研习其后的练习题，这才发现，原先关于“算法罗列”的主观臆断是多么的错误。 是的，本书的确在强调算法，但是除了常规的算法，作者更多的是在表达出一种算法以外的思想：高效的算法没错，但是正确的事情应该用正确的方法来做。 每个算法都有高效的经典例子，但是什么时候用什么样的算法，探究问题的本质，真正的优雅的解决问题，才是本书所要传达的精神。 此外，值得一提的是书中那些传奇的故事，比如太空笔和铅笔，比如各鸽子和胶卷，类似稗官野史，但是又的确是真实发生的事件，在乐趣中一步步的佐证他的观点。（不得不说，这一点，《代码大全》和《深入理解计算机系统》也一样老道，看得令人赏心悦目）。 古人说的茅塞顿开，醍醐灌顶，确实可以用来描述我在读此书时的感受。 15 《编程珠玑(编程珠玑续篇)（第二部）》薄薄的一本书，丝毫无愧于珠玑两个字能把书写薄写精的人都是无比厉害的人物，相信看过K&amp;R的的人都有类似的体会只要看了第一章，我相信你会对这本书佩服得五体投地。一个简洁的小例子，几个看似简单的算法，实际上包含了很多算法设计的思想．看完第一章，我对数据库的几种外排算法有了更深层次的理解本书最大的亮点就是引导你去思考，不停地去思考，思考最佳的解决方案。看本书是一个既痛苦也快乐的历程，痛苦在于你必须竭尽脑汁地去想，运用brain bursting去得出尽可能多尽可能好的方法，快乐在于你提出一个优雅的方案或者对大师的方案拍案叫绝的瞬间 16 《淘宝技术这十年》&gt;两天的时间读完此书，总体评价是“轻松幽默、通俗易懂”。技术上属于科普的写法，不过这已经足够，真要写技术细节，恐怕很多人读不到第三章就要睡着了，再说技术上的东西更多的是靠实践而非看书，对于一个初学者，此书可以看作是大型网站技术登堂入室的引言书，展现了大的场景图画和基本的学习方向，符合此书的自我定位。除了语言幽默、段子不断，此书中众多的微博“大佬”的链接也是很宝贵的资源，一个个链过去，你会发现，当年Eclipse还不太会用的子柳（本书作者）现在成了淘宝技术大学的校长，子柳的师傅、同事等要么成了taobao/tmall/alibaba的经理总裁，要么自己单干成了某某公司的CXO。可见，对于个人的成长，能力和机遇两者缺一不可。一个人首先要保证自己的基本能力达标，然后还需要在合适的时间抱上合适的大腿，这条大腿，可能是一个历史的机遇（如马云），也可能是在合适的时候加入一家合适的公司跟对一个合适的老板（如本书作者和他的众同事们）。“机会总是留给有准备的人”，此乃箴言。 17 《软件架构的艺术》（简称架构之美）&gt;前几天有幸听了本书作者的一次培训，收益良多。老话说的好：纸上得来终觉浅 绝知此事要躬行。平心而论，这本书写的真的不错。系统讲解了软件架构的方方面面。观点清晰，结构严谨。但里面很多内容如果你没有一定的理论和实践基础，理解起来会比较困难，难以引起你的共鸣。走在前面的人总是孤独的，这也是培训中我能感觉到的作者本人的心情。 18 《软件框架设计的艺术》&gt;这是本讲软件架构的实用性书，同时，这也是本架构非常好的书，但由于涉及内容实在太广，所以内容和架构相比显得过于单薄。本书由三大部分组成，第一部分是软件架构的概念，属于理论性部分；第二部分是软件架构本身；第三部分是架构师的各人技能。这个分类一下子把软件架构的众多技术分解为架构技术和个人技能两部分，非常赞。架构概念非常简单，通过众牛人对软件架构的诠释，作者总结了架构的两个功用：软件组成和决策，两者都对，并不冲突，这是作者非常聪明的地方，一下子就缓解了大家的矛盾，并且把所有的观点都汇集到统一的框架之下。软件架构本身，又分为方法和过程两部分。方法既架构的五个视图：物理架构、逻辑架构、数据架构、开发架构和运行视图。过程则分为六个步骤：需求分析、领域建模、确定关键需求、概念性架构设计、细化架构和验证架构。其中概念性架构的作用是规划关键问题的解决策略；细化架构就是生成那五个视图。就像开头说的，这部分内容实在太广，作者只是谈了一些他的经验，实际内容严重不足。个人技能无非就是从编码，设计，UML工具，软件过程四个不同层次来谈，而在设计方面又举了几个解耦合的例子，包括理解依赖关系、角色理论和设计模式等。总的来说，这本书的结构非常好，内容可以按照这个架构通过其他书籍慢慢补充。 19 《软件测试的艺术(原书第2版）》&gt;本书的观点与传统软件测试理论形成了鲜明的对比，作者提出：软件测试的目的不是为了验证软件能够达到设计文档的要求，而是为了发现软件错误而运行软件的过程。当我刚开始学习测试技术的时候，很为该观点所动，但随着工作经验的增长，发现实际操作中无论是组织还是个人都很难达成作者的美好目标。毕竟，公司的预算、资源都很难让测试人员有机会进行所谓的完美测试。但，不管怎样，本书中提到的软件测试方法论对于任何一个从事软件测试甚至是开发人员都是大有裨益的。推荐，5颗星！ 20 《HeadFirst设计模式》&gt;写得很有趣，图文并茂，比起四人帮的那本，好懂了不知道多少倍。计算机世界的head first系列让我想起了阿呆系列，话说新的一集the big bang theory里面lennerd学习橄榄球的时候也有一本阿呆啊，哈哈，跑题了不过只看书学明白设计模式是不可能的，这些只是前人的总结，我们唯有实践实践再实践了。断断续续的看了一遍这本书，印象最深的还是项目中实际用到的那几个模式，比如观察者，状态，单件，工厂等，更加坚定了我实践的决心了哈~ 21 《编程语言实现模式》&gt;自从2002年开始迷上编译原理，这么多年以来一直断断续续地学习，却一直处于半懂不懂且缺乏实践的尴尬境地，以至于都要引以为平生一憾了。昨晚看过本书前两章，感觉作者有两点做得好：一是首先建立大局观，不一上来就陷入细枝末节，这样比较容易入门；二是追求实用性，举的例子都是实际的语言应用，这样比较容易建立直观的联系。这其实也是学习比较复杂的理论时特别要注意的两点，所以最好是先找一本类似本书的入门书，有了大局观和一定的理论和实践基础后再看龙书这样的专业教科书，这样循序渐进，可以少走不少弯路。 三.方法学系列：1 《用户故事与敏捷方法完整》&gt;现在的互联网产品开发早就摆脱了瀑布式的开发方法，不同公司有不同的定义产品需求的方式，书里的用户故事user story实际上和用例use case一样，是产品人员描述用户需求的方法，他得主要优点在于卡片式的形式加上简短的描述文字和约束条件方便交流理解，文档式的产品需求说明书内容繁多不利于与用户和市场人员交流。互联网产品开发和传统的定制软件不一样，需求是自己挖掘出来的，而不是客户提出的，所以没有交流上的问题，所以用户故事和用例相比没有特别的优势，相反用例对于交互的描述对于开发分解task会更有帮助。所以，总结来说，没有最好的，只有最合适的 2 《金矿：精益管理 挖掘利润 （法）伯乐著》&gt;《金矿》以小说的方式，描述了一家濒临破产的企业如何转亏为盈。这家企业即拥有技术优势，又拥有市场优势，但它却陷入了财务困境。危难之际，经验丰富的精益专家帮助企业建立起一套有竞争力的生产运作系统，通过不断改善，消除浪费，大幅度提高了生产效率和质量，库存很快转变为流动资金。本书用最简单的文字，阐述了实施精益生产所面临的挑战和解决方法，对于想要学习精益生产理论的宝宝们来说是一本很好的书。 3 《解析极限编程：拥抱变化（原书第2版）》&gt;喜欢看这种很短的书，站在阳台就看完了，我都佩服我自己。里面有不少思想还是不错的，勇气，信任，开放，勾勒了一幅完全投入激情的工作的情景。里面很重要的一个思想是 把一个大的复杂的事情分解成小事情，先把最核心的事情做完，不断重构，不断快步向前。 4 《持续交付-发布可靠软件的系统方法》&gt;我是“好的程序员的生产力十倍于差的程序员”这句话的信奉者，由此我期望的未来会有很多人数很少但精锐的小的软件开发组织存在。要在这样的未来生存，需要把一切能够自动化的事务都自动化，让宝贵的智力专注在最有价值的业务上。同时作为一个在大型互联网公司工作过数年的开发者，配置管理、部署和运维的复杂和困难另我深感敬畏，这种困难告诉我在开发和运维之间存在“失落的一环”，在这个弱点得到弥补之前，好的程序员也无法充分发挥其生产力。这本持续交付正是讲述了怎么弥补这失落的一环，把开发、提交、自动化测试、持续集成、自动化部署完整的串了起来。另外，infrastructure as code是非常强大的概念，必须学习。 5 《重构极限编程 XP的实践与反思》&gt;TWI 的时候 MX 提到了这本书。这本书非常罕见的列举了很多XP 失败的例子，多数来自于邮件组的讨论。这本书的出现或许会给人了一种感觉，这本书的目的是为了证明XP和Agile是不可行的~然而，事实上，该书的作者恰恰是DSDM（7大敏捷方法族中的一员）的创始人，同时也是敏捷宣言的签署人之一。事实上该书的出现恰好像是一个灯塔，因为 Agile 的特殊性，很容易产生形似而神不合的伪“Agile”实现，从本质上说，这些实践都是反敏捷的，虽然它们都扣上了一个敏捷的帽子。这本书很好的把这些容易出问题的地方列举了出来，起到了一种警醒的作用。 6 《系统化思维导论》&gt;这本书给我最大的收获，就是让我遇到了系统科学这门联系着数百门学科的学科。我读书的一个目的，就是掌握尽可能多元化思维方式，这样的阅读过程让我接触了许多不同的学科系统。但过多的系统也带来一个问题，如何统摄它们的关系呢？以往，我都是以非系统化的思维来进行学科系统的思考，就是一直停留在作者所说的一阶序状态，而这本书带给我新的管理方式——好像在脑子里装了一个全新的数据库管理系统。其次，这本书让我凑巧碰到了另一本书，让我确定了接下来3个月的阅读主题”系统科学“。前中科院院长路甬祥曾说，系统科学是21世纪科学的趋势。我最近初步接触系统科学，惊诧于其对经典科学学科范式的颠覆，并惊异于其对现实中肯看法，深深觉得未来将会被系统科学改变革新，就像以前的文艺复兴，或许甚至可能是有史以来最大的科学革命。 7 《程序员的思维修炼：开发认知潜能的九堂课》&gt;非常棒的方法论。作为程序员，我们喜欢追根溯源，从架构到语言设计，从语言设计到系统内核，从编程到思考大脑的本质。没错为了写出更好的代码，我们想要了解世界上的所有真理。尤其是对大脑，以及我们自身本质的理解。可惜科学依然没有揭开这层面纱，但我们渴望着。Andy Hunt这本书写的正是我们所渴望的东西，以及一些目前科学上的进展。 作为一个人，永远都受限与自身。只有提升自身，才是前进的根本。体育锻炼身体，思维修炼大脑。 8 《高效程序员的45个习惯：敏捷开发修炼之道》&gt;在所有关乎技艺方面的工作，背后都有一个“道”或类似于“禅”的东西，一通百通。有时，你就得放弃已有的工匠情结，更多地要把自己的理念，思想都揉合在一个物件上，这时技术只是一个副产品罢了。今天iPhone的成功，绝不是因为它做工精细，品质优良，重要的是它带给人们简洁，方便的理念，将生活中的例子融合到了上面，屏幕翻页就像翻书一样直接。良质，我班门弄斧理解其中的一层含义是“直觉+判断”。这些都是形而上的，看不见，也摸不着，不好解释，但又确实存在。拥有好的良质，你的直觉和判断会很准。特别是在自然科学，尤其是数学，今日诸多数学定理都是在直觉和判断下“猜”出来的。本书探讨了有关摩托车修理艺术，禅，宗教，自然科学，教育，哲学，数学，个人修行。包含如此广泛，谁敢说这仅仅是一部文学作品呢？ 9 《禅与摩托车维修艺术 罗伯特·M·波西格》&gt;在所有关乎技艺方面的工作，背后都有一个“道”或类似于“禅”的东西，一通百通。有时，你就得放弃已有的工匠情结，更多地要把自己的理念，思想都揉合在一个物件上，这时技术只是一个副产品罢了。今天iPhone的成功，绝不是因为它做工精细，品质优良，重要的是它带给人们简洁，方便的理念，将生活中的例子融合到了上面，屏幕翻页就像翻书一样直接。良质，我班门弄斧理解其中的一层含义是“直觉+判断”。这些都是形而上的，看不见，也摸不着，不好解释，但又确实存在。拥有好的良质，你的直觉和判断会很准。特别是在自然科学，尤其是数学，今日诸多数学定理都是在直觉和判断下“猜”出来的。本书探讨了有关摩托车修理艺术，禅，宗教，自然科学，教育，哲学，数学，个人修行。包含如此广泛，谁敢说这仅仅是一部文学作品呢？ 10 《人月神话》&gt;这本书的格局我很喜欢这本书。这本书从软件的乐趣和苦恼写起，体现了老一辈黑客的纯粹。也体现了生活哲学：莫忘初心。确实，软件对于一个立志于建设的青年来说是最理想的场景：凭空，凭大脑，凭双手，凭一台计算机。比尔盖茨起家的空手套白狼，google的双人组，twitter的大学寝室传奇。包括现在写日志的豆瓣网创始人咖啡馆一周完成故事。IT业是一个传奇的行业，传奇是软件的自然属性。我也喜欢作者宽阔的视野。 四.思想与领导力系列：1 《卓有成效的管理者》&gt;来看《卓有成效的管理者》吧！这本杜拉克的经典著作，尽管少有文采，也没有雄辩，但其间的“道”与“理”之真切和深刻，足以掩盖绝大多数的雄辩和华丽。尽管没有复杂的模型、结构和细致入微的分析（事实上，杜拉克的许多著作都充满了预言），但足以让绝大多数人信服，因为其中的“道”，因为其中的“理”。评价管理的唯一角度是“有效”，如果没有效果，尽管理论上很完美，但依然不能证明是有价值的；如果有效，尽管没有足够的理论证明，但仍然值得我们研究后借鉴。管理并不复杂，只要我们回到了本原上来。怎样才能有效，看看做了一辈子局外人、观察者的杜拉克的总结吧！ 2 《你的灯亮着吗》&gt;类别：逻辑思维，我在犹疑能不能称它为伟大的书，但是可以肯定是一本好书，虽然翻译有些生涩。它揭示了人生是不断探索解决问题的过程，不让自己失去信心的只有一个万有引力。你的“道” 是什么。对问题要知道是谁的问题，问题的本质是什么？这本书知之甚迟，但也不算太晚。 3 《成为技术领导者》&gt;看到温伯格逝世的消息去补读的。之前看过《你的灯亮着吗》，讲问题的定义的，这本《成为技术领导者》与其说讲领导力倒不如说讲如何在组织中解决问题，算是一个系列。这本书其实不太容易读，因为中心理论很清晰，道理也很平实，会让人觉得有点无聊，翻译不太好，事例也过于离散。不过最近一直在思考什么样的组织是最高效的，看了这本书，有很大的启发。书中开始就讲到“全面”(organic)模型，还是“线性”(linear)模型，这一点体会太深刻了。“线性模型”强调组织中人的角色，强调上下级和层级关系，忽略人的多样性；而“全面模型”重视人的多样性，基于这个模型去做假设。“所谓领导力，就是创造这样一个环境，每个人都能在其中发挥更多的能力”。 4 《第五项修炼》&gt;回想自己成长的路上，关于成功、励志方面的书，多多少少也读了一些。曾经有一本书，激励了自己很久，是美国作家罗曼·W·皮尔著的《态度决定一切》。我从中学会了如何树立正确的人生态度，如何坚强而乐观地面对命运抉择。那个时候，印象最深的一句话是“不可如一秒钟前的自己”。是的，人本来每天都在变化之中，因此，如何把握这份变化，实在是一门十分重要的学问。然而，仅仅是态度的确立，是不够的；我们需要切实可行的实践法则，遗憾的是，那本书没有告诉我。接触到《第五项修炼》，我不禁惊叹于这位作者睿智而缜密的思考方式。比起其他大众化的励志书籍，这本书最吸引我的部分，尤其体现在&lt;第九章：自我超越&gt;。全文从对学习型组织的分析入手，来讨论真正的“自我超越”，不仅角度新颖，而且，重要的是，将个人的自我完善放在组织经营管理中分析，对我们每个人而言，具有莫大的实践性意义。 5 《思考快与慢》&gt;一般来说，我会尽量避免“最佳图书”之类的表达，此之蜜糖、彼之毒药，从个人好恶出发的评价往往缺乏参考价值。不过，我很想说 《思考，快与慢》是我见过的最有用的书。原因有三：首先，这是本讲述知识和方法的工具书，有用与否相对客观，可以评价；其次，这本书的主题“如何思考”，涉及全体有脑子的人，远远超过《新华字典》（适用于中文使用者）和《圣经》（适用于基督徒）的适用范围；最后也是最重要的，这本书的结论是基于严谨事实、通过科学方法推导出来的，不管和“常识”是否相符，都不由你不相信。有些人或许会把这本书和那些文字漂亮但全是作者主观之见的心灵、励志书籍相提并论，但这种相似只在表面上，内里的东西则恰好南辕北辙。 6 《麦肯锡方法》&gt;最近抽空重读了这本书，重读之前对这本书的印象基本为零，然而重读后发现，一些方法竟与我的一些读书、个人管理方面的原则一致，而这些原则也极大的提高了我的效率： 以事实为基础：事实有效地弥补了经验不足的缺陷 MECE：相互独立，完全穷尽，三个一级标题最佳 初始假设：不要让初始假设成为思想僵化的借口 不要重新发明轮子 二八法则 关键驱动因素 电梯法则：你可以在30s内向客户准确无误的解释自己的解决方案（产品、企&gt;业） 先摘好摘的果实：及早汇报，取悦顾客 每天绘制一张图表：今天学到的最重要的三件事是什么？ 一次只做一件事 不要妄想烧干大海：你烧干了大海，却只能得到一点盐 五.奇门遁甲系列：1 《软件调试的艺术》&gt;调试对于软件的成败至关重要，正确使用恰当的调试工具可以提高发现和改正错误的效率。《软件调试的艺术》详细介绍了3种调试器，GDB用于逐行跟踪程序、设置断点、检查变量以及查看特定时间程序的执行情况，DDD是流行的GDB的GUI前端，而Eclipse提供完整的集成开发环境。书中不但配合实例讨论了如何管理内存、理解转储内存、跟踪程序找出错误等内容，更涵盖了其他同类书忽略的主题，例如线程、客户／服务器、GUI和并行程序，以及如何躲开常见的调试陷阱。《软件调试的艺术》适合各层次软件开发人员、管理人员和测试人员阅读。 2 《世界是数字的.Brian.W.Kernighan》 《世界是数字的》是世界顶尖计算机科学家Brian W.Kernighan写的一本计算机科普类读物，简明扼要但又深入全面地解释了计算机和通信系统背后的秘密，适合计算机初学者和非计算机专业的人读。这真的是一本好书。对于一个计算机已经学了N年的专业人士来说，这本书也许简单了点，不过我还是认真过了一遍，发现也有一定的收货，因为一个人很难掌握本领域里的所有知识，或多或少会有一些欠缺，总会有一些你以前不知道的，或一直没理解清楚的但又很有必要知晓的知识，我在阅读此书过程中就有这种感觉，经常会有一种恍然大悟的感觉，比如理解了互联网上一些不为人知的跟踪原理。 3 《极客与团队》&gt;总结来说，这本书写的是关于团队和社区的事。什么是团队，为什么要HRT。如何培养团队文化。如何领导团队。如何对付不良行为。如何应对组织问题。如何看待用户。整体来说，把程序员代码以外，与人沟通的事写了个纲领。 4 《计算的本质：深入剖析程序和计算机》&gt;这半年读过的最漂亮的一本书，各种计算模型及某些通用计算模型的等价性、语义分析/语法分析以及最后一章的类型检查系统（给我感觉就是在写一个小的编译器或者解释器）、还有停机问题的具体介绍都非常精彩。最最重要的是，所有的论述都用上了 Ruby 代码，大部分例子理论上都是可以运行的！Ruby 的灵活性（比如代码即数据在某些语言中就不是很方便）给本书某些章节写实现时带来不少便利，第八章作者甚至一本正经胡说八道地用 evaluate function 写了个停机问题的函数，然后想尝试解决哥德巴赫猜想。 5 《计算机科学概论（原书第3版）》&gt;这本书非常全面，几乎包括了计算机专业本科4年所需要学习的课程的基础介绍。如果你是相关专业的学生，应该在大一的时候读读，今后所学的知识就可以融会贯通了！ 6 《计算机系统概论》&gt;无意间发现有人推荐这本书，看了它的介绍，发现讲的是很基础的东西，花一天时间粗略的看了一遍，我的主要关心点在高级语言在汇编、ISA、机器码的实现。出乎意料的讲的很明白。虽然不够深入，但是却能给人一个整体的概念，C程序如何一步一步的硬件实现。 感觉有点像是把数电、计算机结构、C语言、汇编几本书串起来了。在学校虽然这几门课都上过，却都是分离的概念。本书虽然有大量的篇幅讲汇编基础、C语言基础，但还是从中学到不少东西，不得不说，的确是一本好书，推荐给每个学CS及EE的人，哪怕像我一样粗略的读一遍。 7 《人件（原书第3版）》&gt; 在你从事软件开发这个行当的任何一个阶段和任何一个位置你都应该阅读的好书。在这个行业呆得越久，你越会发现这本书讲的这些绝对是真理。 唯一一本我任何时候更换办公位置都随身携带的书 8 《深入理解计算机系统》&gt;如果大学只能带走一本书的话，我选择这本。这是本很有趣的书，了解计算机底层技术是件极富挑战同趣味的事情。大二以后基本没再阅读过哲学历史文学方面的书籍，因为这样的书籍足以给人带来极大乐趣。个人认为这样的书籍，计科专业的本科学生越早接触越好，它会让你比别人更早拥有一个系统的计算机知识，更能触类旁通。如果想从事底层开发或在Linux平台下开发，这本书是很好的选择。另外，这本书的翻译纸张都很不错，很多的词汇译者都在前面做了说明。这是为数不多让人不抱怨翻译的技术书籍，如果英文不过硬，看中文版也是很享受的一件事情。聪明的你会喜欢这本书的。 六.互联网大佬奇迹传记系列：1 《史蒂夫·乔布斯传》&gt;春节七天看完的，不得不承认有好几次心潮澎湃的时候，比如几个产品的诞生。最后并没有直接描写他的死，但病危之后的那些细节却让人印象深刻。乔布斯并没有好的人品，脾气也很差，只是凭借与生俱来的敏锐创造了美好的事物。最后他自己说的，有着综述性质的一段话尤其好。有些描写非常生动，比如乔布斯贯穿始终的哭哭啼啼。他用披头士的 Two of Us 的歌词来形容过跟比尔·盖茨的关系——Two of us have memories longer than the roads that stretches out ahead.尽管时常怒气冲冲，说起这种话来也肉麻得可以。 2 《沃兹传：与苹果一起疯狂》&gt;读完《乔布斯传》这本书，几天后，乔布斯的光环渐渐褪去，并且阅读《沃兹传》，总觉得乔布斯被市场高估了许多，而沃兹被市场低估了许多。必须要承认，乔布斯是很了不起的一个家伙，但早年成名的他，更多地是利用其推销自己和产品的能力，用《引爆点》的关键人物法则来评估的话，沃兹是那个内行，而乔布斯则充当了联络员和推销员的角色，一个产品的流行固然缺少不了后两者的参与，但是后两者的努力是0，内行，那个创造出产品的人，沃兹，才是0前面的1。换句话说，没有沃兹的乔布斯，将会大不一样，而没有乔布斯的沃兹，还是那个沃兹，那个善良的，痴迷于技术的，喜欢恶作剧的，梦想着成为工程师和教师的电子小孩。 3 《图灵的秘密 他的生平、思想及论文解读》&gt;图灵的秘密》由Windows编程大师Charles Petzold耗时多年编写的这本书剖析了现代计算机原理开山之作、阿兰•图灵流芳百世的论文 “On Computable Numbers, with an Application to the Entscheidungsproblem”。图灵在其中描述了一种假想的计算机器，探索了其功能和内在的局限性，由此建立了现代程序设计和可计算性的基础。这本书也像是一本小说，行文间穿插讲述了图灵的成长经历和教育背景，以及他跌宕起伏的一生，包括破解德国恩尼格密码的传奇经历，他对人工智能的探索，他的性取向，以及最终因同性恋的罪名而在41岁时自杀的悲惨结局。全书完整揭示了阿兰•图灵非凡、传奇而悲剧的一生，是了解图灵的思想和生平的极好著作。 4 《苹果首席设计师_乔纳森传》&gt;书的前一小部分还是天才少年的追梦成材之路，由此窥见他对设计的热情、执着（或者说对待自己作品的节操更好？），直到写到他进了苹果，几乎就变成苹果设计的发展历程简介了，可见乔纳森在苹果崛起中的灵魂式作用。从电脑介绍道ipod再到iphone、ipad、macbook，我今天才知道这些带领自己紧跟时代步伐的产品背后有着怎样的考量与坚守，它是如何在我们看来只是一种造型的细节背后抓狂并完善的。比如，它是如何舍弃仿真设计而扁平化的，它是如何解释ipod第一代应当是白色的——“它不仅仅是一种颜色，还是一种中立态度，在两个极端中极明显，又中立”。它真的可以被作为杰出的艺术品来欣赏，因为里面全都是乔纳森团队加上乔布斯的世界观啊。乔纳森和苹果的成功真是对创造的赞美，对理想的歌颂。 5 《雷军：人因梦想而伟大》&gt;有时间也可以看下的鸡汤文，名头很大是雷大大的，不过内容每个人看法不一，感兴趣就自己阅读吧。 6 《马云传》&gt;本书以一个前所未有却又真实切近的视角揭开马云的真面目，没有冗长的说教，没有空洞的吹捧，只有冷静丰富的细节；没有高深的理论，没有虚假的传言，只有通俗、诚恳的陈述，详尽地展现了马云的成长经历、创业生涯和缔造阿里巴巴的全过程。 7 《企鹅凶猛：马化腾的中国功夫》&gt;昨夜了了读完《企鹅凶猛》一书，此刻坐在客厅茶几前写读书笔记。作者通过腾讯发展及业务扩张这条主线，不仅剖析了马化腾的一些经营思路，更引出了互联网行业十年来诸多叱咤风云的焦点人物，读起来竟如传记或江湖小说般精彩。 8 《拒绝平庸 周鸿祎和他的创士记》&gt;1、你要考虑——未来的10-15年，你到底要成为什么样的人？你到底想获得什么？这是最重要的。想想等你35岁同学聚会的时候，你希望呈现在他们面前的是什么样的你。2、梦想很重要，但是锁定梦想却不容易。第一是人随着年龄增长兴趣点也在变；第二是诱惑太多。3、别人在某一点比你强，就会在其他方面比你弱。不要自卑，最重要的是能够吸取教训。4、年轻的时候尽量走远一点。真正的视野开阔不是我们去旅行，而是那些过了脑子再过心最后留下的东西。5、反思，以及细致的剖析自己很重要（需要学习袁春楠）6、不要害怕自己的不完美，重要的是要改。7、只有有能力的人才会得到更多的资源和更大的舞台。8、如果你不喜欢一个地方，尽快找到自己喜欢的东西，值得投入的东西。9、不要想着因为钱多而混在一个地方——一年20万，五年就100万，但是你白搭了5年青春，这值多少钱啊！10、努力奋斗了，迅速成长了，除了发财之外，你还能收获影响力。只要踏踏实实把一件事做下去，每个人都会成功一件事情。11、人生不一定一定能够干成一件大事，但是一定要去追求，去和别人一起干一件很大的事情。12、如果你没有能力，你就没法放弃那家不能让你成长的公司。 9 《比尔盖茨全传》&gt;伟人大多都是天赋秉异，常人难以学习；读了这么多传记，发现这些伟大成功的人都有个共同点：聪明、对事业执著、自信、狂热。 所以作为普通大众的我们来说 我们还需要锻炼这些品质，等待机遇的出现。 10 《阿桑奇自传》&gt;维基解密揭露的那些政治、金融、宗教、军事、外交的丑闻，其实并不让人惊讶。这些东西有史以来就存在，大家都知道只是没有说破。就像齐泽克所说，所有这些阴谋只是“皇帝的新衣”。维基解密所做的就是把它们赤裸裸地暴露出来，使社会保持透明和清廉，真相得到还原。阿桑奇就是那个解密了皇帝新衣的男孩，总是用一份纯真之心去观察和评论，与谣言和黑幕作战。这是一本战斗性很强的书，因而非常吸引人。 11 《马云：我的成功不是偶然，给年轻人的创业课.任雪峰》&gt;1、该书只是引用马云的话，作为每一章，每一节的中心，而其内容都是作者自己的思想，而非马云的，我看到这本书的时候，以为主要是马云讲的，而其实，这是一个误区。2、每一章都有马云教谕，我觉得这只是作者为了讲述其内容，而加上去的卖点，若是要看马云语录，还是直接去找其他关于马云的书，这本书明显不是很多。3、书中的很多例子，应该说不是很新鲜，不算很好。因此，我觉得该书还行，不算上乘，但还过得去，毕竟还是能学到不少知识的。 12 《编程人生_15位软件先驱访谈录》&gt;读完图灵俱乐部译的《编程人生》的前两章，给我第一感觉就是：听君一席话，胜读十年书。 Peter Seibel先生对编程先驱Zawinski、Fitzpatrick的访谈非常精彩。从这两章访谈中，我收获到了以下几点： 保持好奇心，充满激情，编程人生才精彩，编程人生才快乐。著名黑客Zawinski好拆卸电子玩具一样对软件的内在充满了好奇，Fitzpatrick从小就对软件的神奇如痴如醉。同时，Fitzpatrick告诉我们，绝不能把编程仅仅当工作来看待，而应该是一件充满乐趣的事情。换言之，作为一个软件开发者，如果你仅仅以薪资衡量你的代码的话，那么还是赶快找个后路吧。 语言没有优劣之分，在语言之间的优劣性方面打口水战是毫无意义的。在Perl语言方面，Zawinski和Fitzpatrick就存在巨大的分歧。 Zawinski认为Perl的语法太过古怪，数据结构一团糟；而Fitzpatrick就非常喜欢Perl的灵活性。而在C++语言方面，两位大师表现出一直性厌恶型。不过，对C++的厌恶只是厌恶，Fitzpatrick还是得用C++来构建高性能的程序。 大师们与我们同在。Zawinski为Emacs贡献了很多。在我们用Emacs编辑代码时，Zawinsk与我们同在。当我们使用memcache这个Web前端利器时，Fitzpatrick就与我们同在。 教育要从娃娃抓起。Zawinski和Fitzpatrick很小就接触了编程，发现并且发展了这方面的能力，终成一代大师。 做软件产品，情况不同，侧重点也不同。做新产品抢地盘，及时推出质量合格的产品才有生存的机会。而有条件的话，早期更充分的考虑软件产品后面运营可能遭遇到的问题，后面改动的成本就会大大降低。 后面还有十三位大师的访谈录，真想知道会带给我些什么更精彩的内容。 13 《史玉柱自述：我的营销心得》&gt;如题。有兴趣研究营销的可以参考下史大大的广告引流心得。 14 《一网打尽贝佐斯与亚马逊时代》&gt;试读本的内容读完觉得不过瘾关于亚马逊，实在有太多理由让我们去了解商业周刊中文版的封面文章确实很震撼，想了解亚马逊的商业秘密的人，赶紧去先睹为快吧。我想如果是电商人，更应该看看吧好书值得推广，强烈建议电商人组团学习此书我完全相信这本是亚马逊2.0版本的说法，并且比较想看新书全文。 15 《世界因你不同：李开复自传》&gt;“中国一百年才出一个李开复”，这话一点都不为过。另，这书很好读，字里行间都透露着简单和朴素的韵味，即使是在说IT，即使是在说教，但读下来仍是一气呵成而又有发自内心的深深崇敬，绝对是一本励志的好书！ 16 《编程大师访谈录》&gt;绝大多数被采访的程序员都有暑假替学校打工的经历。从言谈中看出，他们很看中这样的经历，很强调这些工作的实际背景和内容，并认为由此加深了对编程工作的理解。很多人就是通过这些暑假工作爱上了编程。但是，他们从未提及在这些工作中获得了什么荣誉称号什么的，而这正是许多中国学生做项目的时候非常在意的。我不得不说现在的高校真的是浮夸、不务实到成了习惯，吹牛吹到自己都信以为真的地步了。那种想踏实进步的人反倒成了另类。大家都懂的，说也懒得说了。 17 《DOOM启世录》&gt;一本讲美国一家游戏公司ID创业历程的书。ID开发出了DOOM和Quake两款当时风靡世界的游戏，收个互联网多人联机游戏。本书详细描写了ID公司创始人如何相识、如何开始一起创建公司、公司壮大、创始人意见不合分道扬镳的过程。对想要在软件及电子游戏方面创业的人有较大的借鉴意义。 1.创业的乐趣。创业更自由，工作更有趣，气氛更活泼时，是最有生产力、创造力的时段。之后公司壮大，人员增多，管理越来越规范，工作就会失去乐趣，变得枯燥无聊。 2.对某件事的热爱，狂热的兴趣是成为大牛的必备要素。因为兴趣，怎么加班都不累！ 3.专注的力量。专注让卡马克成为游戏引擎上的大牛。 4.互联网创业真是暴利。 18 《奇思妙想：15位计算机天才及其重大发现》&gt;原来KMP的灵感来自有限自动机，这才是正解啊！原来LaTeX的作者Lamport竟然是分布式系统专家！原来定义list真的是为了逻辑推理！……那些囫囵咽下去的精妙的算法、数据结构只有放到历史的上下文中才能鲜活起来。 19 《孵化Twitter 从蛮荒到IPO的狂野旅程》&gt;本书详细讲述twitter的发展史。感觉基本上是一部创始人从朋友变敌人，勾心斗角的历史。Twitter本身的产品发展反而相对比较简单。书中披露了许多email、谈话、会议的细节，作者说这些是数百个小时的采访，1000多份内部文件和数不清的互联网上的资料中挖掘出来的。令人吃惊的是书中指名道姓地披露了几位创始人的许多负面的信息。还都不像是编的。 网盘下载链接架构师之路史诗级必读书单吐血整理四个维度系列80+本书链接：https://pan.baidu.com/s/1H1et7CxdjyATyERQDBGvnQ提取码：1kez备注：文件比较大，网盘直接打开会显示损坏，里面已经整理并且压缩好，需要下载后才可以打。 总结：天下没有不劳而获的果实，望各位年轻的朋友，想学技术的朋友，在决心扎入技术道路的路上披荆斩棘，把书弄懂了，再去敲代码，把原理弄懂了，再去实践，将会带给你的人生，你的工作，你的未来一个美梦。 附Java学习之路吐血整理技术书从入门到进阶最全50+本（珍藏版)：https://pymlovelyq.github.io/2018/10/26/java/python从入门到进阶推荐书籍最全整理pdf分享附网盘链接已拿BT豆瓣offer：https://pymlovelyq.github.io/2018/10/20/python/Web前端书单从HTML到JS到AJAX到HTTP从框架到全栈过来人帮你走更少弯路（珍&gt;藏版）：https://pymlovelyq.github.io/2018/10/17/WebFont/机器学习和python学习之路吐血整理技术书从入门到进阶(珍藏版)：https://pymlovelyq.github.io/2018/10/15/machineLearning/学习数据库从入门到进阶书籍pdf版吐血整理推荐（珍藏版：https://pymlovelyq.github.io/2018/10/12/database/C语言推荐书籍从入门到进阶带你走上大牛之路（珍藏版）：https://pymlovelyq.github.io/2018/10/10/CC/算法与数据结构+一点点ACM从入门到进阶吐血整理推荐书单（珍藏版）：https://pymlovelyq.github.io/2018/10/06/Algorithm/安卓入门到进阶推荐书籍整理pdf附网盘链接已拿阿里豆瓣offer(珍藏)：https://pymlovelyq.github.io/2018/09/04/An/]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>程序员</tag>
        <tag>传记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之汉诺塔求解策略《六》]]></title>
    <url>%2F2018%2F09%2F06%2FjavaForSix%2F</url>
    <content type="text"><![CDATA[java版汉诺塔1234567891011121314151617181920212223242526272829public class Hanoi &#123; public static void main(String[] args)&#123; Hanoi.hanoi(3,'A','B','C'); &#125; public static void hanoi(int n,char a,char b,char c)&#123; ZF z = new ZF(); if(n==1)&#123; print(a,c); &#125; else&#123; hanoi(n-1,a,c,b); print(a,c); hanoi(n-1,b,a,c); &#125; System.out.println("---------第"+(ZF.x++)+"次递归---------------------------------"); &#125; public static void print(char a,char c)&#123; System.out.println("盘子从"+a+"---&gt;"+c); &#125;&#125; class ZF &#123; static public int x=1;&#125;//思想是将全局变量X设置成SS类的属性，//再在SS中添加fuzhi方法，来改变X的值。 汉诺塔求解推荐阅读博客：https://www.bilibili.com/video/av7398130/https://blog.csdn.net/xb2355404/article/details/79144451https://www.cnblogs.com/antineutrino/p/3334540.html]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之快速排序的求解策略《五》]]></title>
    <url>%2F2018%2F09%2F04%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E4%BA%94%2F</url>
    <content type="text"><![CDATA[一.快速排序的基本思想:通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。 二.快排的平均运行时间复杂度是:O(nlog(n))。快速排序最坏的时间复杂度是O(n^2）== 冒泡排序最坏时间复杂度也是O(O^2)。 三.3种实现方法 ①固定基准元法 【如果输入序列是随机的，处理时间是可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。 因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2)。 而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为基准元是非常糟糕的，应该立即放弃这种想法。】 ②随机基准元 【这是一种相对安全的策略。 由于基准元的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。 在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。 实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。 所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度】 ③三数取中【引入的原因：虽然随机选取基准时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2）， 要缓解这种情况，就引入了三数取中选取基准。】 四.总结分析： 最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。 可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准元而得到。 事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准元。 显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约5%的比较次数。 五.补充总结 下面代码中 arry[left]可以换为arry[left+(right-left)/2] 实质也就是三值取中法，时间复杂度相对比arry[left]会减少很多。 下面是一个1000个随机的数，可以作为参考数据。 java版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;public class quickSortAlgorithm1 &#123; public static void main(String[] args)&#123; long startTime = System.currentTimeMillis(); //获取开始时间 int[] num=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;; //int[] num=&#123;6,1,2,7,9,3,4,5,10,8&#125;; SortUtils.quickSort(num, 0, num.length-1); System.out.println(Arrays.toString(num)); long endTime = System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间：" + (endTime - startTime) + "ms"); //输出程序运行时间 &#125;&#125;class SortUtils&#123; public static void quickSort(int arry[],int left,int right) &#123; if(left&gt;=right) &#123;//当递归到left（初始值是0）都大于right（初始值是数组长度减一）时候，返回这个数组 return; &#125; // 【重大提醒：基准数的选取对算法的复杂度影响很大，这里采用三值取中法。随机数法看人品。最糟糕就是取第一个数为基准数。】具体见上面特别分析 int p=arry[left];//基准数，后面p等价于数组最左边的数 int i=left,j=right;//i是最左边的数的下标，j是最右边的数的下标 while(i!=j) &#123;//当i不等于j时候，循环下面的操作，也就是说 当i和j相等即相遇的时候，跳出来。 while(arry[j]&gt;=p&amp;&amp;i&lt;j) &#123;//当数组的第j个下标的数大于基准数时（i必须小于j） j--;//j减减 &#125; while(arry[i]&lt;=p&amp;&amp;i&lt;j) &#123;//当数组的第i个小标的数小于基准数时（i必须小于j） i++;//i加加 &#125; //经过上面的操作数组i和j的下标的数都已经各自大于基准数和小于基准数 if(i&lt;j) &#123; //这个时候，就要交换这两个下标的数 int temp=arry[i];//交换两个数 arry[i]=arry[j]; arry[j]=temp; &#125; &#125; //实质是以6位基准数的最后一次交换数字，之后以这个基准数的左边和右边分别递归。 arry[left]=arry[i];//交换基准数1 arry[i]=p;//交换基准数2 quickSort(arry, left, i-1);//选择这个数组原来的基准数的左边进行递归。 quickSort(arry, i+1, right);//选择这个数组原来的基准数的右边进行递归。 &#125;&#125; C语言版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int a[10]=&#123;6,1,2,9,7,4,5,10,8&#125;;//1.首先全局变量定义一个数组int a[1000]=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;;//2.快排函数的三个实参是待快排的数组，//该数组的最左边的下标，该数组最右边的下标。void quickSort(int *arr,int left,int right)&#123; //3.定义i为左哨兵,j为右哨兵,p为基准兵(当前数组的基准兵为当前数组的左哨兵下标的值)看下图示 //6,1,2,9,7,4,5,10,8 //基准哨兵:p //左右哨兵:i j int i=left,j=right,p=arr[left]; //4.左下标大于等于右下标也就是快排排好的时候 if(left&gt;=right)&#123; return; &#125; while(i != j)&#123; while(arr[j]&gt;=p&amp;&amp;i&lt;j)&#123; j--; &#125; while(arr[i]&lt;=p&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; int temp ; temp =arr[i]; arr[i] =arr[j]; arr[j] =temp; &#125; &#125; arr[left] =arr[i]; arr[i] = p; quickSort(arr,left,i-1); quickSort(arr,i+1,right); &#125;int main()//1.写主函数&#123; int i; quickSort(a,0,999);//调用快排函数 for (i=0;i&lt;1000;i++)&#123; printf("%d\n",a[i]);//输出结果，codeblock先ctrl+F11编译，再ctrl+F10运行； &#125; return 0;&#125; 快速排序推荐阅读博客：http://developer.51cto.com/art/201403/430986.htm https://blog.csdn.net/liuyi1207164339/article/details/50827608 https://www.cnblogs.com/surgewong/p/3381438.html http://www.cnblogs.com/foreverking/articles/2234225.html https://www.cnblogs.com/y3w3l/p/6444837.html https://blog.csdn.net/liuzhenya1994/article/details/80254958]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之约瑟夫环问题求解策略《四》]]></title>
    <url>%2F2018%2F08%2F30%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AD%96%E7%95%A5%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.ArrayList;/** * 约瑟夫环 问题 * 获取幸运数字 * 思路： * ①集合数组的 * ②递归 */public class josephRing03 &#123; public static void main(String[] args)&#123; System.out.println("第一种方法：集合法"); System.out.println(getLuckNum01(10)); System.out.println("第二种方法：递归法"); System.out.println(getLuckNum02(10,3,8)); System.out.println(getLuckNum02(9,3,7)); System.out.println(getLuckNum02(8,3,6)); System.out.println(getLuckNum02(7,3,5)); System.out.println(getLuckNum02(6,3,4)); System.out.println(getLuckNum02(5,3,3)); System.out.println(getLuckNum02(4,3,2)); System.out.println("第三种方法：公式法");//本质也是递归 System.out.println(getlive(10, 3)); System.out.println(getlive( 9, 3)); System.out.println(getlive( 8 , 3)); System.out.println("第三.001种方法：公式形象记忆法");//本质也是递归 System.out.println(getLuckNum(10, 3)); System.out.println(getLuckNum(9, 3)); System.out.println(getLuckNum(8, 3)); &#125; //①数组集合法 public static int getLuckNum01(int num) &#123; //1.定义一个集合，并且添加人进去，10环就add十个人进去，100人环就add100个人进去 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= num; i++) &#123; list.add(i); &#125; //2.定义一个指针，区别于下面的i，这个count是直接跟人头对接的，所以要从1开始。 int count = 1; //3.遍历所有元素，一直“杀死”人直到只剩下最后一个人即list.size()!=1时都要继续遍历 /* System.out.println(list.size());*/ for (int i=0;list.size()!=1;i++)&#123; //4.如果已经遍历到最后一个人了，则重新开始，i重新等于0,又一个新环来进行“杀人”游戏 //注：这里要设置判断条件为list.size(),而不是list.size()-1是有原因的 //因为i作为下标一直遍历增加，直到最后一个下标，都是可以杀人的， //也就是说还可以进行下面的if判断以及count++ //所以，直到i增加到list.size时，已经可以说是下标越界了 //此时就要使得要越界的这个i变成0，重新开始新的“i生”（人生~哈哈哈） if(i==list.size())&#123; i =0; &#125; //5.当指针的对3求余为0时，去除掉list的这个元素。 //注：由于少了一个数，后面的数会补上前来，下标不变的话，i又必须得-1，才能不会错过当前的人 if(count%3 == 0)&#123; list.remove(i--); &#125; //6.count继续累加 count++; &#125; return list.get(0); &#125; //②递归法（大神法） public static int getLuckNum02(int sum,int value,int n) &#123; if( n ==1)&#123; return (sum+value-1)%sum; &#125; else&#123; return (getLuckNum02(sum-1, value, n-1)+value)%sum; &#125; &#125; //3.公式法 public static int getlive(int n,int m)&#123; if(n == 1)&#123;return 1;&#125; return (getlive(n-1,m)+m-1)%n+1;//背下来就可以了 &#125; //3.01形象记忆公式法 public static int getLuckNum(int sumMan,int jiange)&#123; if(sumMan == 1) &#123; return 1; &#125; else&#123; return (getLuckNum(sumMan-1,jiange)+jiange-1)%sumMan+1;//背下来就可以了 &#125; &#125;&#125; 总结： ①直接背公式。 ②理解指针指向。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之求长整数中所有0和尾数0的个数的策略《三》]]></title>
    <url>%2F2018%2F08%2F29%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%B1%82%E9%95%BF%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%80%E6%9C%890%E5%92%8C%E5%B0%BE%E6%95%B00%E7%9A%84%E4%B8%AA%E6%95%B0%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89%2F</url>
    <content type="text"><![CDATA[/** 求出：1000的阶乘所有零和尾部零的个数，不用阶乘。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.math.BigInteger;public class test1000For002 &#123; public static void main(String[] args)&#123; //错误方案： //demo01();1000阶乘远大于long的类型范围,行不通。 //正确方案： //calculateTheNumOfZeroTest01(); 求出这个大数字中所有0的个数 //calculateThelastZeroNum02(); 求出这个大数字中尾部0的个数 &#125; public static void calculateThelastZeroNum02() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; String string2 =b1.toString(); StringBuilder sb2 = new StringBuilder(string2); string2 =sb2.reverse().toString();//链式编程，反转字符串再赋值 int count2=0; for (int i = 0; i &lt;string2.length() ; i++) &#123; if('0'==string2.charAt(i))&#123; count2++; &#125; else &#123; break; &#125; &#125; System.out.println(count2);//249 &#125; public static void calculateTheNumOfZeroTest01() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; // System.out.println(b1); String string =b1.toString(); int count=0; /* char[] arr =string.toCharArray();*/ for (int i = 0; i &lt;string.length() ; i++) &#123; if('0' == string.charAt(i))&#123; count++; &#125; &#125; System.out.println(count); &#125; public static void demo01() &#123; long num =1; for(long i=1; i &lt;= 1000;i++)&#123; num =i * num; &#125; System.out.println(num); &#125;&#125; 总结：①当需求的数的个数超过int和long的类型的最大长度时，即2^32-1这个值时，可以利用java自带的类库BigInterger对数字进行字符串化并且利用类的方法进行求值。②考虑到求尾数0的个数，当看到求【尾数类】的题目时，要想到String中没有直接倒过来的方法，要把String放入StringBulidedr中，再利用StringBulider的方法对其进行反转，思路就开了。③链式编程了解一下emmm。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之斐波那契数列题型两种解题策略《二》]]></title>
    <url>%2F2018%2F08%2F28%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%A2%98%E5%9E%8B%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/**不死神兔 月月生问题 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 两种解题思路： ①利用数组 ②递归计算 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* *不死神兔 月月生问题 * 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 * 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 * 两种解题思路： * ①利用数组 * ②递归计算 */public class rabbitTest01 &#123; public static void main(String[] args)&#123; // ①利用数组(7行代码搞定) getRabbitNum01(); //②递归计算(2行代码搞定) //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.利用递归输出,核心是:fun(num) =fun(num-2)+fun(num-1); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+getNum(i+1)+"只"); &#125; &#125; public static int getNum(int i)&#123;//利用三元运算符使代码更简洁 return (i ==1||i ==2) ? 1 :(getNum(i-2)+getNum(i-1)); &#125;/*下面小测试的答案在这里：第10个月————21对大兔子生下21对小兔子————————13对小兔子长成13对大兔子 ——共55对（42+13）你做对了么?对了就请点个喜欢吧~~~*/ public static void getRabbitNum01() &#123; //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.初始化第一和第二个元素为1 arr[0]=arr[1]=1; //3.遍历一下这个数组，也就是让每个月都有个兔子总数值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i-2] +arr[i-1]; &#125; //4.选择输出每个月份的兔子总数，直观清晰 for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+arr[i]+"只"); &#125; &#125;&#125; 总结：规律掌握如下，一点点理解，这个不会太难。月份——————兔子生长情况——————兔子当月总对数第1个月————1对小兔子———————— 共1对第2个月————1对大兔子———————— 共1对第3个月————1对大兔子生下1对小兔子——共2对（1+1）第4个月————1对大兔子生下1对小兔子————————1对小兔子长成1对大兔子 ——共3对（1+2）第5个月————2对大兔子生下2对小兔子————————1对小兔子长成1对大兔子 ——共5对（2+3）第6个月————3对大兔子生下3对小兔子————————2对小兔子长成2对大兔子 ——共8对（6+2）第7个月————5对大兔子生下5对小兔子————————3对小兔子长成3对大兔子 ——共13对（10+3）第8个月————8对大兔子生下8对小兔子————————5对小兔子长成5对大兔子 ——共21对（16+5）第9个月————13对大兔子生下13对小兔子————————8对小兔子长成8对大兔子 ——共34对（26+8）小测试：看你懂了没？第10个月————？对大兔子生下？对小兔子————————？对小兔子长成？对大兔子 ——共？对（？+？）答案藏在本篇文章中，聪明人10秒钟内应该能看到。或者，自己把代码敲一遍，结果自然明白。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之二分查找题型的解题策略《一》]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A2%98%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%A2%98%E7%AD%96%E7%95%A5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 二分查找： 查找元素对应的索引 前提：数组有序，这点特别重要！！！要求的数组一定要按照顺序来的。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546package day13.searchAlgorithm;public class binarySearch &#123; public static void main(String[] args)&#123; int[] arr = &#123;11,22, 33, 44, 55&#125;; System.out.println(binarysearch(arr,11)); System.out.println(binarysearch(arr,22)); System.out.println(binarysearch(arr,33)); System.out.println(binarysearch(arr,44)); System.out.println(binarysearch(arr,55)); System.out.println(binarysearch(arr,66)); System.out.println(binarysearch(arr,77)); &#125; private static boolean binarysearch(int[] arr, int num) &#123; /** * 二分查找3点 * 1.确定 小中大 3个索引 * 2.判断 中索引 的值是否等于 待查值，等于即返回true，不等于进入while循环 * 3.判断 值的索引与中的索引的大小， 中大就大索引改为中大索引-1， 中小就小索引改为中大索引+1， 中大索引本身改为大小索引之和的一半 * 4.当小索引大于大索引时返回false */ int max = arr.length - 1; int min = 0; int mid = (max + min) / 2; Boolean flag; while (arr[mid]!=num) &#123; //当中间值 mid = (max + min) / 2; if (arr[mid] &gt; num) &#123; max = mid - 1; &#125; else if (arr[mid] &lt; num) &#123; min = mid + 1; &#125; if(min&gt;max)&#123; return false; &#125; &#125; return true; &#125;&#125; 总结：二分查找关键在于数组中数字要有序，其次是确定好三个索引的大小关系。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16分钟教你搭建一个Hexo博客>]]></title>
    <url>%2F2018%2F08%2F10%2FHexo%E6%90%AD%E5%BB%BAnext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8F%82%E8%80%83001%2F</url>
    <content type="text"><![CDATA[目的：搭建一个hexo.next主题的博客 用时：大约要16分钟左右 条件：①一个git-bash命令行窗口②一个npm打包工具③一个node.js运行环境④一个gitHub账号]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铭戈栈]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%93%AD%E6%88%88%E6%A0%88%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法：①标题大小 铭戈栈的第一篇博客markDown语法###②大小列表 java a IDE的选择 b 数据类型 c 数组 d 类文件 .class和.java的区别 e String类的使用 c++ 算法 ③引用外链第一种java博客学习对象第二种（优先）java博客学习对象 ##改字体④斜体字/这个字好像是斜体的！！/⑤删除字这是加删除线的文字⑥加粗这是加粗的文字⑦斜体加粗这是斜体加粗的文字 ##插入东西 三个横线： ##引用图片： ##代码区：1234567&lt;html&gt; &lt;title&gt; 我是标题 &lt;/title&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; ##引用区 第一个引用 第二个引用]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>目录</tag>
        <tag>个人简介</tag>
      </tags>
  </entry>
</search>
