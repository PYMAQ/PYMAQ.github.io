<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习从入门到进阶个人储备计划]]></title>
    <url>%2Fposts%2Fe8bf1285%2F</url>
    <content type="text"><![CDATA[一.了解阶段1.知识交集程度图解 总结：机器学习让计算机能够从数据中学习，并根据学习到的数据进行逻辑判断。 深度学习更多地利用“神经网络”技术，让计算机能够根据学习到的数据，模仿人类的大脑进行分析和判断。 深度学习是机器学习的一种，而二者皆隶属于人工智能技术。深度学习技术是目前为止最接近人类思维的人工智能技术。 2.机器学习 二.入门阶段1.前置知识及技能：1、线性代数基础，如果没的话，还是先学了这门课在研究吧，不然会哭的。2、学会python就行了。R也可以用用。3、英语。起码能基本的听和读吧，感觉中文的资料还不够多，很难避免要看很多英文资料。建议学习某些教程时看英文版的tutorial，YouTube可以开字幕。 2.课程 1.Machine Learning | Coursera，入门首选，推荐只认识“机器学习”四个字但还不知道它是什么的学习这些年机器学习的大多数年轻人靠这个入门。具体提纲我就不列了，免得增加篇幅。建议是直接按顺序一课课学，不要着急。在学完这个课程前，不要学后面的。 2.CS231n: Convolutional Neural Networks for Visual RecognitionStanford最受欢迎的课之一。做图像识别的，就算不想搞图像识别，也会学到很多有用的通用的东西。 三. 深入阶段：四. 进阶阶段：五. 本文引用：1.《人工智能、机器学习和深度学习的区别?》https://www.zhihu.com/question/57770020/answers/updated 2.《深度学习如何入门？》https://www.zhihu.com/question/26006703/answer/536169538 3.《我的机器学习入门学习清单及路线 》https://zhuanlan.zhihu.com/p/27018536]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习思维导图</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05_JavaWeb基础_《mybatis踩坑记录01》]]></title>
    <url>%2Fposts%2F5e16deed%2F</url>
    <content type="text"><![CDATA[记录1学习mybatis遇到一个报错123456789101112Exception in thread &quot;main&quot; java.lang.AbstractMethodError: Method com/mysql/jdbc/PreparedStatement.isClosed()Z is abstract at com.mysql.jdbc.PreparedStatement.isClosed(PreparedStatement.java) at org.apache.ibatis.executor.BaseExecutor.closeStatement(BaseExecutor.java:285) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:65) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:136) at test.TestMyBatis.main(TestMyBatis.java:29) 解决办法：一直发现不了原因，原来是mysql的jar包问题，需要5.1.x版本及以上的，一开始用的是5.0.x版本,报错了，试了8.0版本的太高了。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fposts%2F0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java面试题之汉诺塔求解策略《六》]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[java版汉诺塔1234567891011121314151617181920212223242526272829public class Hanoi &#123; public static void main(String[] args)&#123; Hanoi.hanoi(3,'A','B','C'); &#125; public static void hanoi(int n,char a,char b,char c)&#123; ZF z = new ZF(); if(n==1)&#123; print(a,c); &#125; else&#123; hanoi(n-1,a,c,b); print(a,c); hanoi(n-1,b,a,c); &#125; System.out.println("---------第"+(ZF.x++)+"次递归---------------------------------"); &#125; public static void print(char a,char c)&#123; System.out.println("盘子从"+a+"---&gt;"+c); &#125;&#125; class ZF &#123; static public int x=1;&#125;//思想是将全局变量X设置成SS类的属性，//再在SS中添加fuzhi方法，来改变X的值。 汉诺塔求解推荐阅读博客：https://www.bilibili.com/video/av7398130/https://blog.csdn.net/xb2355404/article/details/79144451https://www.cnblogs.com/antineutrino/p/3334540.html]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之快速排序的求解策略《五》]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[一.快速排序的基本思想:通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。 二.快排的平均运行时间复杂度是:O(nlog(n))。快速排序最坏的时间复杂度是O(n^2）== 冒泡排序最坏时间复杂度也是O(O^2)。 三.3种实现方法 ①固定基准元法 【如果输入序列是随机的，处理时间是可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。 因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2)。 而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为基准元是非常糟糕的，应该立即放弃这种想法。】 ②随机基准元 【这是一种相对安全的策略。 由于基准元的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。 在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。 实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。 所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度】 ③三数取中【引入的原因：虽然随机选取基准时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2）， 要缓解这种情况，就引入了三数取中选取基准。】 四.总结分析： 最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。 可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准元而得到。 事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准元。 显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约5%的比较次数。 五.补充总结 下面代码中 arry[left]可以换为arry[left+(right-left)/2] 实质也就是三值取中法，时间复杂度相对比arry[left]会减少很多。 下面是一个1000个随机的数，可以作为参考数据。 java版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;public class quickSortAlgorithm1 &#123; public static void main(String[] args)&#123; long startTime = System.currentTimeMillis(); //获取开始时间 int[] num=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;; //int[] num=&#123;6,1,2,7,9,3,4,5,10,8&#125;; SortUtils.quickSort(num, 0, num.length-1); System.out.println(Arrays.toString(num)); long endTime = System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间：" + (endTime - startTime) + "ms"); //输出程序运行时间 &#125;&#125;class SortUtils&#123; public static void quickSort(int arry[],int left,int right) &#123; if(left&gt;=right) &#123;//当递归到left（初始值是0）都大于right（初始值是数组长度减一）时候，返回这个数组 return; &#125; // 【重大提醒：基准数的选取对算法的复杂度影响很大，这里采用三值取中法。随机数法看人品。最糟糕就是取第一个数为基准数。】具体见上面特别分析 int p=arry[left];//基准数，后面p等价于数组最左边的数 int i=left,j=right;//i是最左边的数的下标，j是最右边的数的下标 while(i!=j) &#123;//当i不等于j时候，循环下面的操作，也就是说 当i和j相等即相遇的时候，跳出来。 while(arry[j]&gt;=p&amp;&amp;i&lt;j) &#123;//当数组的第j个下标的数大于基准数时（i必须小于j） j--;//j减减 &#125; while(arry[i]&lt;=p&amp;&amp;i&lt;j) &#123;//当数组的第i个小标的数小于基准数时（i必须小于j） i++;//i加加 &#125; //经过上面的操作数组i和j的下标的数都已经各自大于基准数和小于基准数 if(i&lt;j) &#123; //这个时候，就要交换这两个下标的数 int temp=arry[i];//交换两个数 arry[i]=arry[j]; arry[j]=temp; &#125; &#125; //实质是以6位基准数的最后一次交换数字，之后以这个基准数的左边和右边分别递归。 arry[left]=arry[i];//交换基准数1 arry[i]=p;//交换基准数2 quickSort(arry, left, i-1);//选择这个数组原来的基准数的左边进行递归。 quickSort(arry, i+1, right);//选择这个数组原来的基准数的右边进行递归。 &#125;&#125; C语言版快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int a[10]=&#123;6,1,2,9,7,4,5,10,8&#125;;//1.首先全局变量定义一个数组int a[1000]=&#123;1244,1060,1826,1976,230,68,169,735,2089,1533,1914,186,1714,1764,1931,2089,1468,36,109,1518,1588,1068,648,153,1530,1231,584,1009,1685,97,138,1274,181,1706,186,1440,648,1346,415,1596,1593,2012,1125,1322,927,534,39,1051,821,1700,711,1783,401,704,1759,848,226,1668,1514,1630,1847,1029,53,1214,1316,1155,1194,665,1569,1063,1442,1388,1775,287,1949,1608,1172,430,118,255,866,1687,450,2135,203,1975,1951,62,743,808,1658,178,1855,1303,1953,626,814,872,1427,601,529,287,1706,2136,109,158,1989,260,436,1245,1984,302,1382,1437,2012,116,944,247,1377,590,1030,1236,710,880,214,1802,1996,602,1577,1012,1340,204,1519,194,237,862,1006,543,819,1830,1709,835,1902,1271,1744,1794,1061,1890,2050,1351,1892,901,199,1612,1091,891,74,584,545,1966,1645,1303,2075,1480,942,1572,462,1598,1263,217,920,1060,943,917,680,1805,1845,1582,222,522,354,4,1476,345,765,1194,388,1981,1058,1684,427,1320,561,493,1942,79,455,1818,429,677,496,1749,1605,1515,2116,290,1901,1553,1695,1305,245,937,1764,989,219,1408,1554,1816,1378,392,1553,1084,1173,382,1782,1180,2002,767,436,344,1924,1691,49,1670,1812,862,578,641,1497,1542,215,1018,969,617,1088,1529,241,2014,1599,1810,2040,463,1304,1223,1704,605,433,1029,1223,1414,808,207,1309,1199,1106,694,2058,1733,972,146,433,596,1198,382,771,497,1877,92,1043,1628,305,1427,1349,810,2004,992,287,1136,1404,1456,1212,1609,2135,613,1923,393,118,2132,497,1746,656,190,58,488,1303,1583,534,673,920,779,1644,1388,961,1966,856,1049,1683,176,919,1786,1818,1149,1471,588,1860,804,626,1909,815,1985,868,71,1535,284,962,1085,3,11,1325,1039,1717,542,877,384,110,166,486,690,1758,1754,790,121,1415,1851,853,1927,736,260,1279,1761,115,1066,2146,343,236,1129,182,1993,997,1441,1513,1531,894,1882,1675,1118,1018,906,1549,159,622,1608,229,808,2044,1951,330,1724,668,1547,1527,1123,163,1530,912,600,249,740,2122,2098,793,1861,1605,166,358,1807,1859,1588,408,1628,269,785,445,300,2060,564,1722,1339,1050,2066,1414,36,669,1875,431,268,528,939,938,1311,1816,1290,974,1676,1154,1862,115,1238,296,2004,1720,1720,1823,1088,1640,1824,1769,1392,138,646,176,1504,298,459,544,1711,1138,507,464,1555,1105,1045,1859,103,970,1426,1029,838,339,1009,777,1715,541,452,367,522,1549,714,1679,527,1680,1608,1375,104,1978,1246,1001,243,1167,1146,1484,165,906,1858,1913,1533,733,2141,1704,709,1938,1036,1023,1578,159,1088,1970,2022,1625,487,1057,1881,487,1231,2036,833,74,1146,2040,1442,473,62,511,922,1876,361,258,2124,1178,232,1378,992,1754,1043,1359,1112,1643,1508,1941,774,664,2047,663,670,1280,1130,111,816,1534,1370,1341,1608,110,1241,1449,37,560,1311,309,1591,1490,1549,1334,852,116,250,43,951,639,570,500,23,696,322,1045,611,1928,1354,362,403,100,1544,228,689,1715,1338,1616,897,436,1621,798,1596,187,2105,1052,524,1145,987,849,19,1639,103,1826,1987,1576,857,1792,1922,1617,1170,1022,2113,1172,1215,901,1801,1883,1583,1313,379,1206,1439,721,145,1059,1366,1961,1719,554,1724,2048,1564,317,11,1589,816,137,1787,581,985,1605,1304,697,1613,2074,235,921,1111,1032,1095,2002,1582,2126,1473,632,1849,1973,171,1411,568,1908,112,1712,463,515,1697,1832,1431,1592,181,1140,1004,328,219,1873,1352,2,823,1136,2077,126,1005,2058,2028,1520,1624,1277,1461,423,1322,1871,45,1190,1015,819,13,700,1880,25,975,725,2011,18,1538,950,1529,1240,13,767,1003,1398,601,550,53,133,965,754,1248,1006,1359,664,1404,1652,1440,1442,978,328,1316,1926,1707,1385,1970,2121,2031,588,377,443,406,940,611,1173,2013,876,1358,303,1211,500,242,1078,1383,525,1287,1913,355,349,573,1784,72,1277,1550,1059,778,863,1931,755,1318,400,1884,749,854,244,1123,518,576,1419,1430,377,1922,1375,390,743,1209,719,1718,966,566,921,2100,357,1745,531,128,1354,1561,386,239,2048,1963,1789,472,467,374,255,981,996,1118,1398,95,1686,1845,46,1929,251,240,770,1424,2041,855,1766,1273,679,1793,986,812,1205,898,1658,1332,1288,1346,1219,384,1762,52,1701,916,1344,162,1873,777,208,1809,25,1080,907,1033,1317,1911,1620,638,1272,787,639,1955,1294,1230,1229,1247,1759,1982,1206,1896,827,177,636,724,1426,1945,2112,459,2072,1302,502,1074,2031,1251,1024,1530,611,2122,457,141,541,1437,1280,1385,1593,2042,523,238,90,695,1947,1870,2099,1343,1953,2089,1228,1210,2097,1664,796,201,1730,776,1399,756,1877,843,1837,639,1551,91,1164,410,788,253,1346,15,263,612,1691,1382,82,1881,1175,1101,798,1368,551,143,1586,1891,1562,1456,1066,608,1885,671,1239,584,301,1082,1135,1046,1906,1475,1934,473,1224,1642,1815,495,695,1492,479,767,874,1529,1331,1245,991,842,71,1622,1548,577,228,679,748,684,1591,1519,201,1518,1967,392,597,137,951,1081,1883,737,1935,1810,2080,97,1637,1985,421,426,1925,911,101,683,651,1299,1604,1319&#125;;//2.快排函数的三个实参是待快排的数组，//该数组的最左边的下标，该数组最右边的下标。void quickSort(int *arr,int left,int right)&#123; //3.定义i为左哨兵,j为右哨兵,p为基准兵(当前数组的基准兵为当前数组的左哨兵下标的值)看下图示 //6,1,2,9,7,4,5,10,8 //基准哨兵:p //左右哨兵:i j int i=left,j=right,p=arr[left]; //4.左下标大于等于右下标也就是快排排好的时候 if(left&gt;=right)&#123; return; &#125; while(i != j)&#123; while(arr[j]&gt;=p&amp;&amp;i&lt;j)&#123; j--; &#125; while(arr[i]&lt;=p&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; int temp ; temp =arr[i]; arr[i] =arr[j]; arr[j] =temp; &#125; &#125; arr[left] =arr[i]; arr[i] = p; quickSort(arr,left,i-1); quickSort(arr,i+1,right); &#125;int main()//1.写主函数&#123; int i; quickSort(a,0,999);//调用快排函数 for (i=0;i&lt;1000;i++)&#123; printf("%d\n",a[i]);//输出结果，codeblock先ctrl+F11编译，再ctrl+F10运行； &#125; return 0;&#125; 快速排序推荐阅读博客：http://developer.51cto.com/art/201403/430986.htm https://blog.csdn.net/liuyi1207164339/article/details/50827608 https://www.cnblogs.com/surgewong/p/3381438.html http://www.cnblogs.com/foreverking/articles/2234225.html https://www.cnblogs.com/y3w3l/p/6444837.html https://blog.csdn.net/liuzhenya1994/article/details/80254958]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03_JavaWeb基础_《SpringBoot项目踩坑记录01》]]></title>
    <url>%2Fposts%2F3b95cbb0%2F</url>
    <content type="text"><![CDATA[遇到的坑：1.pdf复制过来的会自带空格，但是idea发现不了，会报错。解决办法：删除重新打 2.maven配置的plugins的包下面报红线解决办法：https://www.cnblogs.com/best-lwj/articles/9221309.html 删除所有以lastUpdated结尾的文件重新点击reimport即可 3.pdf的配置直接粘贴到pom文件和xml文件，然后昨天pom文件报错，今天xml文件报错我错了 低级问题联系两个坑 估计这辈子都忘不了了emmmm 4.Maven run 的时候错误Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.0.6.RELEASE:repackage (default) on project spring-boot-01-hello: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:2.0.6.RELEASE:repackage failed: Plugin org.springframework.boot:spring-boot-maven-plugin:2.0.6.RELEASE or one of its dependencies could not be resolved: Failed to collect dependencies at org.springframework.boot:spring-boot-maven-plugin:jar:2.0.6.RELEASE -&gt; org.apache.maven:maven-archiver:jar:2.6 -&gt; org.codehaus.plexus:plexus-archiver:jar:2.8.1: Failed to read artifact descriptor for org.codehaus.plexus:plexus-archiver:jar:2.8.1: Could not transfer artifact org.codehaus.plexus:plexus-components:pom:1.3 from/to alimaven (http://maven.aliyun.com/nexus/content/groups/public/): maven.aliyun.com: Unknown host maven.aliyun.com -&gt; [Help 1][ERROR] 莫名其妙好了，可能是因为加了依赖： 1234567891011121314 &lt;properties&gt; &lt;start-class&gt; com.mengxuegu.springboot.HelloMainApplication &lt;/start-class&gt; &lt;project.build.sourceEncoding&gt; UTF-8 &lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt; UTF-8 &lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt; 1.8 &lt;/java.version&gt;&lt;/properties&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之约瑟夫环问题求解策略《四》]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.ArrayList;/** * 约瑟夫环 问题 * 获取幸运数字 * 思路： * ①集合数组的 * ②递归 */public class josephRing03 &#123; public static void main(String[] args)&#123; System.out.println("第一种方法：集合法"); System.out.println(getLuckNum01(10)); System.out.println("第二种方法：递归法"); System.out.println(getLuckNum02(10,3,8)); System.out.println(getLuckNum02(9,3,7)); System.out.println(getLuckNum02(8,3,6)); System.out.println(getLuckNum02(7,3,5)); System.out.println(getLuckNum02(6,3,4)); System.out.println(getLuckNum02(5,3,3)); System.out.println(getLuckNum02(4,3,2)); System.out.println("第三种方法：公式法");//本质也是递归 System.out.println(getlive(10, 3)); System.out.println(getlive( 9, 3)); System.out.println(getlive( 8 , 3)); System.out.println("第三.001种方法：公式形象记忆法");//本质也是递归 System.out.println(getLuckNum(10, 3)); System.out.println(getLuckNum(9, 3)); System.out.println(getLuckNum(8, 3)); &#125; //①数组集合法 public static int getLuckNum01(int num) &#123; //1.定义一个集合，并且添加人进去，10环就add十个人进去，100人环就add100个人进去 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= num; i++) &#123; list.add(i); &#125; //2.定义一个指针，区别于下面的i，这个count是直接跟人头对接的，所以要从1开始。 int count = 1; //3.遍历所有元素，一直“杀死”人直到只剩下最后一个人即list.size()!=1时都要继续遍历 /* System.out.println(list.size());*/ for (int i=0;list.size()!=1;i++)&#123; //4.如果已经遍历到最后一个人了，则重新开始，i重新等于0,又一个新环来进行“杀人”游戏 //注：这里要设置判断条件为list.size(),而不是list.size()-1是有原因的 //因为i作为下标一直遍历增加，直到最后一个下标，都是可以杀人的， //也就是说还可以进行下面的if判断以及count++ //所以，直到i增加到list.size时，已经可以说是下标越界了 //此时就要使得要越界的这个i变成0，重新开始新的“i生”（人生~哈哈哈） if(i==list.size())&#123; i =0; &#125; //5.当指针的对3求余为0时，去除掉list的这个元素。 //注：由于少了一个数，后面的数会补上前来，下标不变的话，i又必须得-1，才能不会错过当前的人 if(count%3 == 0)&#123; list.remove(i--); &#125; //6.count继续累加 count++; &#125; return list.get(0); &#125; //②递归法（大神法） public static int getLuckNum02(int sum,int value,int n) &#123; if( n ==1)&#123; return (sum+value-1)%sum; &#125; else&#123; return (getLuckNum02(sum-1, value, n-1)+value)%sum; &#125; &#125; //3.公式法 public static int getlive(int n,int m)&#123; if(n == 1)&#123;return 1;&#125; return (getlive(n-1,m)+m-1)%n+1;//背下来就可以了 &#125; //3.01形象记忆公式法 public static int getLuckNum(int sumMan,int jiange)&#123; if(sumMan == 1) &#123; return 1; &#125; else&#123; return (getLuckNum(sumMan-1,jiange)+jiange-1)%sumMan+1;//背下来就可以了 &#125; &#125;&#125; 总结： ①直接背公式。 ②理解指针指向。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之求长整数中所有0和尾数0的个数的策略《三》]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[/** 求出：1000的阶乘所有零和尾部零的个数，不用阶乘。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.math.BigInteger;public class test1000For002 &#123; public static void main(String[] args)&#123; //错误方案： //demo01();1000阶乘远大于long的类型范围,行不通。 //正确方案： //calculateTheNumOfZeroTest01(); 求出这个大数字中所有0的个数 //calculateThelastZeroNum02(); 求出这个大数字中尾部0的个数 &#125; public static void calculateThelastZeroNum02() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; String string2 =b1.toString(); StringBuilder sb2 = new StringBuilder(string2); string2 =sb2.reverse().toString();//链式编程，反转字符串再赋值 int count2=0; for (int i = 0; i &lt;string2.length() ; i++) &#123; if('0'==string2.charAt(i))&#123; count2++; &#125; else &#123; break; &#125; &#125; System.out.println(count2);//249 &#125; public static void calculateTheNumOfZeroTest01() &#123; BigInteger b1 =new BigInteger("1"); for (int i=1 ;i&lt;=1000;i++)&#123; BigInteger b2 = new BigInteger(i+""); b1 = b1.multiply(b2); &#125; // System.out.println(b1); String string =b1.toString(); int count=0; /* char[] arr =string.toCharArray();*/ for (int i = 0; i &lt;string.length() ; i++) &#123; if('0' == string.charAt(i))&#123; count++; &#125; &#125; System.out.println(count); &#125; public static void demo01() &#123; long num =1; for(long i=1; i &lt;= 1000;i++)&#123; num =i * num; &#125; System.out.println(num); &#125;&#125; 总结：①当需求的数的个数超过int和long的类型的最大长度时，即2^32-1这个值时，可以利用java自带的类库BigInterger对数字进行字符串化并且利用类的方法进行求值。②考虑到求尾数0的个数，当看到求【尾数类】的题目时，要想到String中没有直接倒过来的方法，要把String放入StringBulidedr中，再利用StringBulider的方法对其进行反转，思路就开了。③链式编程了解一下emmm。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00_踩坑记录]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[记录： 中文踩坑： ①Servlet的正文前，正文后，加中文 req.setCharacterEncoding(“UTF-8”); ② response.setContentType(“text/html; charset=UTF-8”);]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSP</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之斐波那契数列题型两种解题策略《二》]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[/**不死神兔 月月生问题 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 两种解题思路： ①利用数组 ②递归计算 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* *不死神兔 月月生问题 * 假设一对刚出生的小兔一个月后会长成大兔，再过一个月就会生下一对小兔，并且此后每个月都会生下一对兔子 * 问：一对刚出生的兔子，一年内可以繁殖成多少对兔子 * 两种解题思路： * ①利用数组 * ②递归计算 */public class rabbitTest01 &#123; public static void main(String[] args)&#123; // ①利用数组(7行代码搞定) getRabbitNum01(); //②递归计算(2行代码搞定) //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.利用递归输出,核心是:fun(num) =fun(num-2)+fun(num-1); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+getNum(i+1)+"只"); &#125; &#125; public static int getNum(int i)&#123;//利用三元运算符使代码更简洁 return (i ==1||i ==2) ? 1 :(getNum(i-2)+getNum(i-1)); &#125;/*下面小测试的答案在这里：第10个月————21对大兔子生下21对小兔子————————13对小兔子长成13对大兔子 ——共55对（42+13）你做对了么?对了就请点个喜欢吧~~~*/ public static void getRabbitNum01() &#123; //1.定义一个数组，数组大小意味着第几个月的兔子数量 int numRabbit =12; int[] arr =new int[numRabbit]; //2.初始化第一和第二个元素为1 arr[0]=arr[1]=1; //3.遍历一下这个数组，也就是让每个月都有个兔子总数值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i-2] +arr[i-1]; &#125; //4.选择输出每个月份的兔子总数，直观清晰 for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println("第"+(i+1)+"个月的兔子数量是"+arr[i]+"只"); &#125; &#125;&#125; 总结：规律掌握如下，一点点理解，这个不会太难。月份——————兔子生长情况——————兔子当月总对数第1个月————1对小兔子———————— 共1对第2个月————1对大兔子———————— 共1对第3个月————1对大兔子生下1对小兔子——共2对（1+1）第4个月————1对大兔子生下1对小兔子————————1对小兔子长成1对大兔子 ——共3对（1+2）第5个月————2对大兔子生下2对小兔子————————1对小兔子长成1对大兔子 ——共5对（2+3）第6个月————3对大兔子生下3对小兔子————————2对小兔子长成2对大兔子 ——共8对（6+2）第7个月————5对大兔子生下5对小兔子————————3对小兔子长成3对大兔子 ——共13对（10+3）第8个月————8对大兔子生下8对小兔子————————5对小兔子长成5对大兔子 ——共21对（16+5）第9个月————13对大兔子生下13对小兔子————————8对小兔子长成8对大兔子 ——共34对（26+8）小测试：看你懂了没？第10个月————？对大兔子生下？对小兔子————————？对小兔子长成？对大兔子 ——共？对（？+？）答案藏在本篇文章中，聪明人10秒钟内应该能看到。或者，自己把代码敲一遍，结果自然明白。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题之二分查找题型的解题策略《一》]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[/* 二分查找： 查找元素对应的索引 前提：数组有序，这点特别重要！！！要求的数组一定要按照顺序来的。 */12345678910111213141516171819202122232425262728293031323334353637383940414243444546package day13.searchAlgorithm;public class binarySearch &#123; public static void main(String[] args)&#123; int[] arr = &#123;11,22, 33, 44, 55&#125;; System.out.println(binarysearch(arr,11)); System.out.println(binarysearch(arr,22)); System.out.println(binarysearch(arr,33)); System.out.println(binarysearch(arr,44)); System.out.println(binarysearch(arr,55)); System.out.println(binarysearch(arr,66)); System.out.println(binarysearch(arr,77)); &#125; private static boolean binarysearch(int[] arr, int num) &#123; /** * 二分查找3点 * 1.确定 小中大 3个索引 * 2.判断 中索引 的值是否等于 待查值，等于即返回true，不等于进入while循环 * 3.判断 值的索引与中的索引的大小， 中大就大索引改为中大索引-1， 中小就小索引改为中大索引+1， 中大索引本身改为大小索引之和的一半 * 4.当小索引大于大索引时返回false */ int max = arr.length - 1; int min = 0; int mid = (max + min) / 2; Boolean flag; while (arr[mid]!=num) &#123; //当中间值 mid = (max + min) / 2; if (arr[mid] &gt; num) &#123; max = mid - 1; &#125; else if (arr[mid] &lt; num) &#123; min = mid + 1; &#125; if(min&gt;max)&#123; return false; &#125; &#125; return true; &#125;&#125; 总结：二分查找关键在于数组中数字要有序，其次是确定好三个索引的大小关系。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16分钟教你搭建一个Hexo博客>]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[目的：搭建一个hexo.next主题的博客 用时：大约要16分钟左右 条件：①一个git-bash命令行窗口②一个npm打包工具③一个node.js运行环境④一个gitHub账号]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
